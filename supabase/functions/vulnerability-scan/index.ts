import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { SIGNATURE_DATABASE, VulnerabilitySignature } from "./signatures.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// ═══════════════════════════════════════════════════════════════
// CONFIGURATION & CONSTANTS
// ═══════════════════════════════════════════════════════════════

const CONFIG = {
  MAX_BODY_SIZE: 5 * 1024 * 1024, // 5MB max body
  REQUEST_TIMEOUT: 15000, // 15 seconds
  MAX_REDIRECTS: 5,
  USER_AGENT: 'SentinelX-Scanner/2.0 (Security Assessment Tool)',
  RETRY_ATTEMPTS: 2,
  RETRY_DELAY: 1000,
};

// ═══════════════════════════════════════════════════════════════
// LOCAL SIGNATURE DATABASE (MERGED WITH IMPORTS)
// ═══════════════════════════════════════════════════════════════

interface VulnerabilitySignature {
  id: string;
  title: string;
  owasp_category: string;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  detection_type: 'header_missing' | 'header_value' | 'content_match' | 'tech_fingerprint' | 'behavior' | 'misconfiguration';
  pattern?: string | RegExp;
  header_name?: string;
  expected_value?: string | RegExp;
  negative_match?: boolean;
  confidence_base: number;
  recommendation: string;
  references: string[];
}

const LOCAL_SIGNATURES: VulnerabilitySignature[] = [
  // A01:2021 - Broken Access Control
  {
    id: "SIG-A01-001",
    title: "Directory Listing Enabled",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "medium",
    detection_type: "content_match",
    pattern: /Index of \/[a-zA-Z]/i,
    confidence_base: 92,
    recommendation: "Disable directory listing in web server configuration",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },
  {
    id: "SIG-A01-002",
    title: "Exposed Admin Panel",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "high",
    detection_type: "content_match",
    pattern: /(admin portal|administration panel|control panel|management console)/i,
    confidence_base: 60,
    recommendation: "Implement proper authentication and restrict admin panel access",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },
  {
    id: "SIG-A01-004",
    title: "Wildcard CORS Configuration",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "high",
    detection_type: "header_value",
    header_name: "access-control-allow-origin",
    expected_value: "*",
    confidence_base: 95,
    recommendation: "Restrict CORS to specific trusted domains instead of wildcard",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },

  // A02:2021 - Cryptographic Failures
  {
    id: "SIG-A02-001",
    title: "Missing Strict-Transport-Security Header",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "high",
    detection_type: "header_missing",
    header_name: "strict-transport-security",
    negative_match: true,
    confidence_base: 85,
    recommendation: "Add HSTS header: Strict-Transport-Security: max-age=31536000; includeSubDomains; preload",
    references: ["https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"]
  },
  {
    id: "SIG-A02-002",
    title: "Weak HSTS Configuration",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "medium",
    detection_type: "header_value",
    header_name: "strict-transport-security",
    expected_value: /max-age=([0-9]+)/,
    confidence_base: 70,
    recommendation: "Set HSTS max-age to at least 31536000 (1 year)",
    references: ["https://hstspreload.org/"]
  },
  {
    id: "SIG-A02-003",
    title: "Insecure Cookie Configuration",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "medium",
    detection_type: "header_value",
    header_name: "set-cookie",
    expected_value: /(?!.*Secure)(?!.*HttpOnly)/,
    confidence_base: 75,
    recommendation: "Set Secure and HttpOnly flags on all cookies",
    references: ["https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"]
  },

  // A03:2021 - Injection
  {
    id: "SIG-A03-001",
    title: "Potential SQL Error Exposure",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /(SQL syntax.*MySQL|pg_query\(\)|ORA-[0-9]{5}:|SQLite3::SQLException|SQLSTATE\[)/i,
    confidence_base: 90,
    recommendation: "Implement proper error handling and never expose database errors to users",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },
  {
    id: "SIG-A03-002",
    title: "Stack Trace Exposure",
    owasp_category: "A03:2021 - Injection",
    severity: "medium",
    detection_type: "content_match",
    pattern: /(at [A-Za-z0-9_$]+\.[A-Za-z0-9_$]+\([^)]*:[0-9]+\)|Traceback \(most recent call last\):|Exception in thread)/i,
    confidence_base: 92,
    recommendation: "Disable debug mode in production and implement custom error pages",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },
  {
    id: "SIG-A03-003",
    title: "Potential XSS Vulnerability",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /<script[^>]*>(?!.*nonce=)|javascript:\s*[a-zA-Z]/i,
    confidence_base: 50,
    recommendation: "Implement Content Security Policy and proper input sanitization",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },

  // A04:2021 - Insecure Design
  {
    id: "SIG-A04-001",
    title: "Missing Content-Security-Policy",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "content-security-policy",
    negative_match: true,
    confidence_base: 70,
    recommendation: "Implement a strict Content Security Policy",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },
  {
    id: "SIG-A04-002",
    title: "Weak Content-Security-Policy",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_value",
    header_name: "content-security-policy",
    expected_value: /'unsafe-inline'|'unsafe-eval'|\*(?!\.)(?![a-z])/,
    confidence_base: 65,
    recommendation: "Remove unsafe-inline, unsafe-eval, and wildcard sources from CSP",
    references: ["https://content-security-policy.com/"]
  },
  {
    id: "SIG-A04-003",
    title: "Missing X-Frame-Options",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "x-frame-options",
    negative_match: true,
    confidence_base: 75,
    recommendation: "Add X-Frame-Options: DENY or SAMEORIGIN to prevent clickjacking",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },

  // A05:2021 - Security Misconfiguration
  {
    id: "SIG-A05-001",
    title: "Server Version Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "server",
    expected_value: /(Apache|nginx|IIS|Tomcat|Express)\/[0-9]+\.[0-9]+/i,
    confidence_base: 90,
    recommendation: "Remove or obscure server version information",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-002",
    title: "X-Powered-By Header Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "x-powered-by",
    expected_value: /.+/,
    confidence_base: 85,
    recommendation: "Remove X-Powered-By header to prevent technology disclosure",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-003",
    title: "Missing X-Content-Type-Options",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "x-content-type-options",
    negative_match: true,
    confidence_base: 70,
    recommendation: "Add X-Content-Type-Options: nosniff to prevent MIME-sniffing",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-004",
    title: "Missing Referrer-Policy",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "referrer-policy",
    negative_match: true,
    confidence_base: 60,
    recommendation: "Implement Referrer-Policy: no-referrer or strict-origin-when-cross-origin",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-005",
    title: "Exposed Git Directory",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /\[core\][\s\S]*repositoryformatversion|ref: refs\/heads\//,
    confidence_base: 98,
    recommendation: "Block access to .git directory immediately",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-006",
    title: "Exposed Environment Variables",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /(DB_PASSWORD|DATABASE_URL|API_SECRET|PRIVATE_KEY)\s*[=:]\s*["']?[^\s"']{8,}/i,
    confidence_base: 95,
    recommendation: "Remove .env and configuration files from web-accessible directories",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },

  // A06:2021 - Vulnerable and Outdated Components
  {
    id: "SIG-A06-001",
    title: "WordPress Detection",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "info",
    detection_type: "tech_fingerprint",
    pattern: /wp-content\/|wp-includes\/|\/wp-json\//i,
    confidence_base: 95,
    recommendation: "Ensure WordPress and all plugins are up to date",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },
  {
    id: "SIG-A06-002",
    title: "Outdated jQuery Detected",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "medium",
    detection_type: "tech_fingerprint",
    pattern: /jquery[.-]([12]\.[0-9]+|3\.[0-4])\./i,
    confidence_base: 80,
    recommendation: "Update jQuery to the latest version (3.7.0+)",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },
  {
    id: "SIG-A06-003",
    title: "PHP Version Disclosure",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "medium",
    detection_type: "header_value",
    header_name: "x-powered-by",
    expected_value: /PHP\/([5-7]\.[0-4]|8\.0)/i,
    confidence_base: 90,
    recommendation: "Remove PHP version header and ensure PHP is updated to latest secure version",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },

  // A07:2021 - Identification and Authentication Failures
  {
    id: "SIG-A07-001",
    title: "Weak Session Cookie Configuration",
    owasp_category: "A07:2021 - Identification and Authentication Failures",
    severity: "high",
    detection_type: "header_value",
    header_name: "set-cookie",
    expected_value: /(session|sid|auth)/i,
    confidence_base: 60,
    recommendation: "Ensure session cookies have Secure, HttpOnly, and SameSite flags",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },
  {
    id: "SIG-A07-002",
    title: "Login Page Without Rate Limiting",
    owasp_category: "A07:2021 - Identification and Authentication Failures",
    severity: "medium",
    detection_type: "content_match",
    pattern: /<form[^>]*>[\s\S]*?<input[^>]*type\s*=\s*["']password["']/i,
    confidence_base: 55,
    recommendation: "Implement rate limiting and account lockout mechanisms",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },

  // A08:2021 - Software and Data Integrity Failures
  {
    id: "SIG-A08-001",
    title: "Missing Subresource Integrity",
    owasp_category: "A08:2021 - Software and Data Integrity Failures",
    severity: "medium",
    detection_type: "content_match",
    pattern: /<script[^>]+src=["']https?:\/\/(?!localhost)[^"']+["'][^>]*(?!integrity=)/i,
    confidence_base: 70,
    recommendation: "Add Subresource Integrity (SRI) hashes to external scripts",
    references: ["https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/"]
  },

  // A09:2021 - Security Logging and Monitoring Failures
  {
    id: "SIG-A09-001",
    title: "Debug Mode Enabled",
    owasp_category: "A09:2021 - Security Logging and Monitoring Failures",
    severity: "high",
    detection_type: "content_match",
    pattern: /(var_dump\s*\(|print_r\s*\(|debugger;|DEBUG\s*[:=]\s*true)/i,
    confidence_base: 85,
    recommendation: "Disable debug mode in production environments",
    references: ["https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/"]
  },

  // A10:2021 - Server-Side Request Forgery (SSRF)
  {
    id: "SIG-A10-001",
    title: "Potential SSRF via URL Parameter",
    owasp_category: "A10:2021 - Server-Side Request Forgery",
    severity: "high",
    detection_type: "behavior",
    pattern: /[?&](url|uri|redirect|callback|proxy|fetch|load)=https?/i,
    confidence_base: 45,
    recommendation: "Validate and whitelist allowed URLs, use URL parsing libraries",
    references: ["https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/"]
  },

  // Additional Checks
  {
    id: "SIG-EXT-001",
    title: "Missing Permissions-Policy Header",
    owasp_category: "Privacy & Security",
    severity: "low",
    detection_type: "header_missing",
    header_name: "permissions-policy",
    negative_match: true,
    confidence_base: 55,
    recommendation: "Add Permissions-Policy header to control browser features",
    references: ["https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy"]
  },
  {
    id: "SIG-EXT-002",
    title: "Missing X-Frame-Options",
    owasp_category: "Clickjacking Protection",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "x-frame-options",
    negative_match: true,
    confidence_base: 75,
    recommendation: "Add X-Frame-Options: DENY or implement frame-ancestors in CSP",
    references: ["https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"]
  },
  {
    id: "SIG-EXT-003",
    title: "Sensitive Path in Robots.txt",
    owasp_category: "Information Disclosure",
    severity: "low",
    detection_type: "content_match",
    pattern: /Disallow:\s*\/(admin|private|secret|internal|backup|config)/i,
    confidence_base: 65,
    recommendation: "Review robots.txt for sensitive path disclosures",
    references: ["https://www.robotstxt.org/"]
  },
];

// Merge local and imported signatures, avoiding duplicates
const MERGED_SIGNATURES = [...LOCAL_SIGNATURES];
if (SIGNATURE_DATABASE && Array.isArray(SIGNATURE_DATABASE)) {
  for (const sig of SIGNATURE_DATABASE) {
    if (!MERGED_SIGNATURES.find(s => s.id === sig.id)) {
      MERGED_SIGNATURES.push(sig);
    }
  }
}

// ═══════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════

interface ScanContext {
  url: string;
  finalUrl: string;
  headers: Record<string, string>;
  body: string;
  statusCode: number;
  responseTime: number;
  isHttps: boolean;
  hostname: string;
}

interface VulnerabilityFinding {
  id: string;
  title: string;
  owasp_category: string;
  status: 'immune' | 'vulnerable' | 'unknown';
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  evidence: string[];
  recommendation: string;
  references: string[];
  explanation?: string;
  confidence_factors?: string[];
}

// Trusted domains with enterprise-grade security
const TRUSTED_DOMAINS = new Set([
  'google.com', 'microsoft.com', 'apple.com', 'amazon.com', 'facebook.com',
  'cloudflare.com', 'github.com', 'linkedin.com', 'twitter.com', 'netflix.com',
  'mozilla.org', 'youtube.com', 'bing.com', 'yahoo.com', 'stripe.com',
  'paypal.com', 'salesforce.com', 'zoom.us', 'slack.com', 'atlassian.com',
  'vercel.app', 'netlify.app', 'herokuapp.com', 'cloudfront.net',
  'akamai.net', 'fastly.net', 'supabase.co', 'firebase.google.com',
  'lovable.dev', 'preview--*.lovable.app'
]);

// CDN domains that handle security at infrastructure level
const CDN_DOMAINS = new Set([
  'cloudflare.com', 'cloudfront.net', 'akamaihd.net', 'fastly.net',
  'stackpathdns.com', 'jsdelivr.net', 'unpkg.com', 'cdnjs.cloudflare.com'
]);

function validateUrl(input: string): { valid: boolean; url?: URL; error?: string } {
  try {
    // Trim and basic sanitization
    const trimmed = input.trim();
    if (!trimmed) {
      return { valid: false, error: 'URL is empty' };
    }

    // Ensure URL has protocol
    let urlString = trimmed;
    if (!urlString.match(/^https?:\/\//i)) {
      urlString = `https://${urlString}`;
    }

    const url = new URL(urlString);

    // Block dangerous protocols
    if (!['http:', 'https:'].includes(url.protocol)) {
      return { valid: false, error: 'Only HTTP and HTTPS protocols are allowed' };
    }

    // Block internal/local addresses
    const hostname = url.hostname.toLowerCase();
    const blockedPatterns = [
      /^localhost$/i,
      /^127\./,
      /^10\./,
      /^192\.168\./,
      /^172\.(1[6-9]|2[0-9]|3[01])\./,
      /^169\.254\./,
      /^::1$/,
      /^0\.0\.0\.0$/,
      /\.local$/i,
      /\.internal$/i,
    ];

    for (const pattern of blockedPatterns) {
      if (pattern.test(hostname)) {
        return { valid: false, error: 'Cannot scan local or internal addresses' };
      }
    }

    return { valid: true, url };
  } catch (error) {
    return { valid: false, error: `Invalid URL format: ${error instanceof Error ? error.message : 'Unknown error'}` };
  }
}

function isTrustedDomain(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  for (const domain of TRUSTED_DOMAINS) {
    if (domain.includes('*')) {
      const regex = new RegExp(domain.replace(/\*/g, '[a-z0-9-]+'));
      if (regex.test(lower)) return true;
    } else if (lower === domain || lower.endsWith('.' + domain)) {
      return true;
    }
  }
  return false;
}

function isCdnDomain(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  for (const domain of CDN_DOMAINS) {
    if (lower === domain || lower.endsWith('.' + domain)) {
      return true;
    }
  }
  return false;
}

function hasScriptNonce(body: string): boolean {
  return /<script[^>]*nonce=["'][^"']+["']/i.test(body);
}

function hasScriptSri(body: string): boolean {
  return /<script[^>]*integrity=["']sha(256|384|512)-[^"']+["']/i.test(body);
}

function isMinifiedContent(content: string): boolean {
  if (content.length < 500) return false;
  const lines = content.split('\n').filter(l => l.trim().length > 0);
  const avgLineLength = content.length / Math.max(lines.length, 1);
  return avgLineLength > 300;
}

function analyzeCookieSecurity(cookieHeader: string): { 
  secure: boolean; 
  httpOnly: boolean; 
  sameSite: string | null;
  isSessionCookie: boolean;
} {
  const lower = cookieHeader.toLowerCase();
  const sameSiteMatch = lower.match(/samesite=(strict|lax|none)/i);
  return {
    secure: lower.includes('secure'),
    httpOnly: lower.includes('httponly'),
    sameSite: sameSiteMatch ? sameSiteMatch[1] : null,
    isSessionCookie: /^(session|sid|ssid|auth|token)/i.test(cookieHeader)
  };
}

function analyzeHsts(hstsHeader: string): { 
  valid: boolean; 
  maxAge: number; 
  includeSubDomains: boolean;
  preload: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  const maxAgeMatch = hstsHeader.match(/max-age=(\d+)/i);
  const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1]) : 0;
  const includeSubDomains = /includeSubDomains/i.test(hstsHeader);
  const preload = /preload/i.test(hstsHeader);

  if (maxAge < 31536000) {
    issues.push(`max-age is ${maxAge}s (${(maxAge / 86400).toFixed(0)} days), should be ≥31536000s (1 year)`);
  }
  if (!includeSubDomains) {
    issues.push('Missing includeSubDomains directive');
  }
  if (!preload && maxAge >= 31536000 && includeSubDomains) {
    issues.push('Could add preload directive for HSTS preload list eligibility');
  }

  return {
    valid: maxAge >= 31536000,
    maxAge,
    includeSubDomains,
    preload,
    issues
  };
}

function analyzeCsp(cspHeader: string): {
  present: boolean;
  issues: string[];
  score: number;
} {
  const issues: string[] = [];
  let score = 100;

  if (!cspHeader) {
    return { present: false, issues: ['CSP header is missing'], score: 0 };
  }

  if (/'unsafe-inline'/.test(cspHeader)) {
    issues.push("Contains 'unsafe-inline' which weakens XSS protection");
    score -= 25;
  }
  if (/'unsafe-eval'/.test(cspHeader)) {
    issues.push("Contains 'unsafe-eval' which allows eval() execution");
    score -= 25;
  }
  if (/\*(?!\.)(?!-)/g.test(cspHeader)) {
    issues.push("Contains wildcard (*) sources");
    score -= 20;
  }
  if (!/default-src/i.test(cspHeader)) {
    issues.push("Missing default-src directive");
    score -= 15;
  }
  if (!/script-src/i.test(cspHeader) && !/default-src/i.test(cspHeader)) {
    issues.push("Missing script-src directive");
    score -= 15;
  }

  return { present: true, issues, score: Math.max(0, score) };
}

// ═══════════════════════════════════════════════════════════════
// FETCH WITH RETRY AND TIMEOUT
// ═══════════════════════════════════════════════════════════════

async function fetchWithRetry(
  url: string,
  options: RequestInit,
  retries = CONFIG.RETRY_ATTEMPTS
): Promise<{ response: Response; responseTime: number }> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), CONFIG.REQUEST_TIMEOUT);

    try {
      const startTime = Date.now();
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });
      const responseTime = Date.now() - startTime;
      clearTimeout(timeoutId);
      return { response, responseTime };
    } catch (error) {
      clearTimeout(timeoutId);
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt < retries) {
        console.log(`[Scan] Retry ${attempt + 1}/${retries} for ${url}: ${lastError.message}`);
        await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (attempt + 1)));
      }
    }
  }

  throw lastError || new Error('Failed to fetch URL after retries');
}

// ═══════════════════════════════════════════════════════════════
// SIGNATURE MATCHING ENGINE
// ═══════════════════════════════════════════════════════════════

function matchSignature(signature: VulnerabilitySignature, context: ScanContext): VulnerabilityFinding | null {
  const evidence: string[] = [];
  const confidenceFactors: string[] = [];
  let matched = false;
  let confidence = signature.confidence_base;
  let explanation = '';

  const trusted = isTrustedDomain(context.hostname);
  const isCdn = isCdnDomain(context.hostname);

  // Normalize headers
  const normalizedHeaders: Record<string, string> = {};
  Object.keys(context.headers).forEach(key => {
    normalizedHeaders[key.toLowerCase()] = context.headers[key];
  });

  confidenceFactors.push(`Base: ${signature.confidence_base}%`);

  // Apply contextual adjustments
  if (trusted) {
    confidenceFactors.push(`Trusted domain (-20%)`);
    confidence = Math.max(20, confidence - 20);
  }
  if (isCdn) {
    confidenceFactors.push(`CDN-hosted (-15%)`);
    confidence = Math.max(25, confidence - 15);
  }
  if (context.isHttps) {
    // HTTPS is a good sign for some checks
    if (signature.id.includes('A02')) {
      confidenceFactors.push(`HTTPS enabled (+5%)`);
      confidence = Math.min(100, confidence + 5);
    }
  } else {
    // Non-HTTPS is concerning
    confidenceFactors.push(`No HTTPS (+10%)`);
    confidence = Math.min(100, confidence + 10);
  }

  switch (signature.detection_type) {
    case 'header_missing': {
      const headerExists = signature.header_name && normalizedHeaders[signature.header_name.toLowerCase()];
      
      if (signature.negative_match) {
        if (!headerExists) {
          matched = true;
          evidence.push(`Header '${signature.header_name}' is not present`);
          explanation = `The security header '${signature.header_name}' was not found. This header provides protection against ${signature.title.toLowerCase().replace('missing ', '')}.`;
          
          // Check for alternative protections
          if (signature.header_name?.toLowerCase() === 'x-frame-options') {
            const csp = normalizedHeaders['content-security-policy'];
            if (csp && /frame-ancestors/i.test(csp)) {
              return {
                id: signature.id,
                title: 'X-Frame-Options (Alternative in CSP)',
                owasp_category: signature.owasp_category,
                status: 'immune',
                severity: 'info',
                confidence: 90,
                evidence: ['frame-ancestors directive found in CSP'],
                recommendation: 'Clickjacking protection is implemented via CSP frame-ancestors.',
                references: signature.references,
                explanation: 'While X-Frame-Options header is missing, the Content-Security-Policy includes frame-ancestors directive which provides equivalent or better protection.',
                confidence_factors: ['90% - CSP frame-ancestors provides equivalent protection']
              };
            }
          }
        } else {
          // Header exists - immune
          return {
            id: signature.id,
            title: signature.title,
            owasp_category: signature.owasp_category,
            status: 'immune',
            severity: signature.severity,
            confidence: 95,
            evidence: [`Header '${signature.header_name}' present: ${headerExists.substring(0, 100)}`],
            recommendation: `The ${signature.header_name} header is properly configured.`,
            references: signature.references,
            explanation: `The security header '${signature.header_name}' is present and provides protection.`,
            confidence_factors: ['95% - Header explicitly present']
          };
        }
      }
      break;
    }

    case 'header_value': {
      if (!signature.header_name) break;
      const headerValue = normalizedHeaders[signature.header_name.toLowerCase()];
      
      if (!headerValue) break;

      // Special cookie handling
      if (signature.header_name.toLowerCase() === 'set-cookie') {
        const cookieAnalysis = analyzeCookieSecurity(headerValue);
        
        // Only flag session cookies without security flags
        if (!cookieAnalysis.isSessionCookie) {
          return null; // Non-session cookies are lower priority
        }

        if (cookieAnalysis.secure && cookieAnalysis.httpOnly) {
          return {
            id: signature.id,
            title: 'Secure Cookie Configuration',
            owasp_category: signature.owasp_category,
            status: 'immune',
            severity: 'info',
            confidence: 95,
            evidence: [`Cookie has Secure and HttpOnly flags${cookieAnalysis.sameSite ? `, SameSite=${cookieAnalysis.sameSite}` : ''}`],
            recommendation: 'Cookie security is properly implemented.',
            references: signature.references,
            explanation: 'Session cookie is configured with appropriate security flags.',
            confidence_factors: ['95% - All critical cookie flags present']
          };
        }

        const missingFlags: string[] = [];
        if (!cookieAnalysis.secure) missingFlags.push('Secure');
        if (!cookieAnalysis.httpOnly) missingFlags.push('HttpOnly');
        if (!cookieAnalysis.sameSite) missingFlags.push('SameSite');

        if (missingFlags.length > 0) {
          matched = true;
          evidence.push(`Session cookie missing flags: ${missingFlags.join(', ')}`);
          explanation = `Session cookie lacks ${missingFlags.join(' and ')} flag(s), which could expose it to interception or theft.`;
        }
        break;
      }

      // Special HSTS handling
      if (signature.header_name.toLowerCase() === 'strict-transport-security') {
        const hstsAnalysis = analyzeHsts(headerValue);
        
        if (hstsAnalysis.valid) {
          return {
            id: signature.id,
            title: 'HSTS Properly Configured',
            owasp_category: signature.owasp_category,
            status: 'immune',
            severity: 'info',
            confidence: 95,
            evidence: [`HSTS max-age=${hstsAnalysis.maxAge}s (${(hstsAnalysis.maxAge / 86400 / 365).toFixed(1)} years)`],
            recommendation: hstsAnalysis.issues.length > 0 ? `Minor improvements possible: ${hstsAnalysis.issues.join('; ')}` : 'HSTS is properly configured.',
            references: signature.references,
            explanation: 'HSTS header is configured with appropriate max-age value.',
            confidence_factors: ['95% - HSTS max-age meets or exceeds 1 year minimum']
          };
        } else {
          matched = true;
          evidence.push(`Weak HSTS: ${hstsAnalysis.issues.join('; ')}`);
          explanation = `HSTS configuration has issues: ${hstsAnalysis.issues.join('. ')}`;
        }
        break;
      }

      // Generic header value matching
      if (signature.expected_value) {
        if (typeof signature.expected_value === 'string') {
          if (headerValue.includes(signature.expected_value)) {
            matched = true;
            evidence.push(`Header '${signature.header_name}' contains: ${signature.expected_value}`);
          }
        } else if (signature.expected_value instanceof RegExp) {
          const match = headerValue.match(signature.expected_value);
          if (match) {
            matched = true;
            evidence.push(`Header '${signature.header_name}' matched pattern: ${match[0]}`);
          }
        }
      }
      break;
    }

    case 'content_match': {
      if (!signature.pattern) break;
      const regex = typeof signature.pattern === 'string' 
        ? new RegExp(signature.pattern, 'i') 
        : signature.pattern;

      // XSS check - skip if using CSP nonces or SRI
      if (signature.id === 'SIG-A03-003' || signature.title.toLowerCase().includes('xss')) {
        if (hasScriptNonce(context.body)) {
          return {
            id: signature.id,
            title: 'XSS Protection via CSP Nonces',
            owasp_category: signature.owasp_category,
            status: 'immune',
            severity: 'info',
            confidence: 90,
            evidence: ['Scripts use CSP nonces for authentication'],
            recommendation: 'Continue using CSP nonces for XSS protection.',
            references: signature.references,
            explanation: 'Page uses Content Security Policy nonces, which authenticate inline scripts and prevent XSS.',
            confidence_factors: ['90% - CSP nonces detected on script tags']
          };
        }
      }

      // Debug mode check - validate with multiple patterns
      if (signature.id === 'SIG-A09-001' || signature.title.toLowerCase().includes('debug')) {
        const debugPatterns = [
          { re: /var_dump\s*\(/g, name: 'PHP var_dump()' },
          { re: /print_r\s*\(/g, name: 'PHP print_r()' },
          { re: /debugger\s*;/g, name: 'JS debugger' },
          { re: /DEBUG\s*[:=]\s*['"]?true['"]?/gi, name: 'DEBUG=true' },
          { re: /console\.(log|debug|trace)\s*\([^)]+\)/g, name: 'console.log()' },
        ];

        const foundPatterns: string[] = [];
        for (const { re, name } of debugPatterns) {
          if (re.test(context.body)) {
            foundPatterns.push(name);
          }
        }

        if (foundPatterns.length === 0) {
          return null; // No real debug patterns
        }

        if (isMinifiedContent(context.body) && foundPatterns.length < 2) {
          // Minified content with only 1 match is likely a false positive
          return null;
        }

        matched = true;
        evidence.push(`Debug patterns found: ${foundPatterns.join(', ')}`);
        explanation = `Active debugging code detected: ${foundPatterns.join(', ')}. These should be removed in production.`;
        break;
      }

      // Login page check - must have actual form
      if (signature.id === 'SIG-A07-002' || signature.title.toLowerCase().includes('login')) {
        const hasPasswordField = /<input[^>]*type\s*=\s*["']password["']/i.test(context.body);
        const hasForm = /<form[^>]*>/i.test(context.body);
        
        if (!hasPasswordField || !hasForm) {
          return null; // Not a real login page
        }

        // Check for rate limiting indicators
        const hasRateLimiting = 
          normalizedHeaders['x-ratelimit-limit'] ||
          normalizedHeaders['x-rate-limit-limit'] ||
          normalizedHeaders['retry-after'] ||
          /captcha|recaptcha|hcaptcha|turnstile/i.test(context.body);

        if (hasRateLimiting) {
          return {
            id: signature.id,
            title: 'Login Page with Rate Limiting',
            owasp_category: signature.owasp_category,
            status: 'immune',
            severity: 'info',
            confidence: 85,
            evidence: ['Login form detected with rate limiting or CAPTCHA protection'],
            recommendation: 'Brute-force protection is implemented.',
            references: signature.references,
            explanation: 'Login page includes rate limiting headers or CAPTCHA challenge.',
            confidence_factors: ['85% - Rate limiting or CAPTCHA detected']
          };
        }

        matched = true;
        evidence.push('Login form without visible rate limiting protection');
        explanation = 'Login page detected without rate limiting headers or CAPTCHA. This could allow brute-force attacks.';
        break;
      }

      // Admin panel check - must be actual admin URL
      if (signature.id === 'SIG-A01-002' || signature.title.toLowerCase().includes('admin')) {
        const adminUrlPatterns = /\/(admin|administrator|wp-admin|control-panel|management|backend)\/?$/i;
        if (!adminUrlPatterns.test(context.finalUrl)) {
          return null; // Not a real admin panel URL
        }
        matched = true;
        evidence.push(`Admin endpoint: ${context.finalUrl}`);
        explanation = 'Administrative interface detected. Ensure proper authentication and access controls.';
        break;
      }

      // Generic content match
      const contentMatch = context.body.match(regex);
      if (contentMatch) {
        // Skip common false positives in minified code
        if (isMinifiedContent(context.body) && signature.severity !== 'critical') {
          const reduction = 30;
          confidence = Math.max(20, confidence - reduction);
          confidenceFactors.push(`Minified content (-${reduction}%)`);
        }

        matched = true;
        const snippet = context.body.substring(
          Math.max(0, (contentMatch.index || 0) - 20),
          Math.min(context.body.length, (contentMatch.index || 0) + contentMatch[0].length + 20)
        ).replace(/[\n\r]/g, ' ');
        evidence.push(`Pattern matched: ...${snippet}...`);
        explanation = `Content matches vulnerability signature for ${signature.owasp_category}.`;
      }
      break;
    }

    case 'tech_fingerprint': {
      if (!signature.pattern) break;
      const regex = typeof signature.pattern === 'string' 
        ? new RegExp(signature.pattern, 'i') 
        : signature.pattern;

      const match = context.body.match(regex) || context.finalUrl.match(regex);
      if (match) {
        matched = true;
        evidence.push(`Technology detected: ${match[0].substring(0, 50)}`);
        explanation = `${signature.title} - Ensure all components are up-to-date with security patches.`;
      }
      break;
    }

    case 'behavior': {
      if (!signature.pattern) break;
      const regex = typeof signature.pattern === 'string' 
        ? new RegExp(signature.pattern, 'i') 
        : signature.pattern;

      const match = context.finalUrl.match(regex);
      if (match) {
        matched = true;
        evidence.push(`URL pattern: ${match[0]}`);
        explanation = `URL contains pattern that may indicate ${signature.title.toLowerCase()}.`;
      }
      break;
    }

    case 'misconfiguration': {
      if (!signature.pattern) break;
      const regex = typeof signature.pattern === 'string' 
        ? new RegExp(signature.pattern, 'i') 
        : signature.pattern;

      const match = context.body.match(regex);
      if (match) {
        matched = true;
        evidence.push(`Configuration issue: ${match[0].substring(0, 60)}`);
        explanation = `Potential misconfiguration detected that could lead to security issues.`;
      }
      break;
    }
  }

  if (matched) {
    return {
      id: signature.id,
      title: signature.title,
      owasp_category: signature.owasp_category,
      status: 'vulnerable',
      severity: signature.severity,
      confidence: Math.round(confidence),
      evidence,
      recommendation: signature.recommendation,
      references: signature.references,
      explanation: explanation || `Potential ${signature.severity} severity issue detected.`,
      confidence_factors: confidenceFactors
    };
  }

  return null;
}

// ═══════════════════════════════════════════════════════════════
// PLATFORM & RESOURCE DETECTION
// ═══════════════════════════════════════════════════════════════

interface PlatformInfo {
  name: string;
  confidence: number;
  version?: string;
  indicators: string[];
  category: string;
}

interface ResourceTypeInfo {
  type: string;
  confidence: number;
  indicators: string[];
  description: string;
}

const PLATFORM_SIGNATURES = [
  // CMS
  { pattern: /wp-content\/|wp-includes\/|\/wp-json\//i, name: 'WordPress', category: 'CMS', confidence: 95 },
  { pattern: /Drupal|drupal\.settings/i, name: 'Drupal', category: 'CMS', confidence: 90 },
  { pattern: /Joomla|option=com_/i, name: 'Joomla', category: 'CMS', confidence: 90 },
  
  // E-commerce
  { pattern: /Shopify\.theme|cdn\.shopify/i, name: 'Shopify', category: 'E-commerce', confidence: 95 },
  { pattern: /WooCommerce|wc-ajax/i, name: 'WooCommerce', category: 'E-commerce', confidence: 90 },
  { pattern: /Magento|mage\/|static\/version/i, name: 'Magento', category: 'E-commerce', confidence: 85 },
  
  // Frameworks
  { pattern: /__NEXT_DATA__|_next\//i, name: 'Next.js', category: 'Framework', confidence: 95 },
  { pattern: /ng-version|angular\//i, name: 'Angular', category: 'Framework', confidence: 90 },
  { pattern: /__NUXT__|_nuxt\//i, name: 'Nuxt.js', category: 'Framework', confidence: 95 },
  { pattern: /data-reactroot|react-dom/i, name: 'React', category: 'Framework', confidence: 80 },
  { pattern: /vue\.js|v-bind:|v-on:/i, name: 'Vue.js', category: 'Framework', confidence: 85 },
  { pattern: /__svelte/i, name: 'Svelte', category: 'Framework', confidence: 90 },
  
  // Hosting/CDN
  { pattern: /x-vercel-|vercel\.app/i, name: 'Vercel', category: 'Hosting', confidence: 95, headerCheck: true },
  { pattern: /x-netlify|netlify\.app/i, name: 'Netlify', category: 'Hosting', confidence: 95, headerCheck: true },
  { pattern: /cf-ray|cloudflare/i, name: 'Cloudflare', category: 'CDN', confidence: 90, headerCheck: true },
  
  // Servers
  { pattern: /Server:\s*nginx/i, name: 'Nginx', category: 'Server', confidence: 95, headerCheck: true },
  { pattern: /Server:\s*Apache/i, name: 'Apache', category: 'Server', confidence: 95, headerCheck: true },
  { pattern: /X-Powered-By:\s*PHP/i, name: 'PHP', category: 'Backend', confidence: 95, headerCheck: true },
  { pattern: /X-Powered-By:\s*Express/i, name: 'Express.js', category: 'Backend', confidence: 95, headerCheck: true },
];

const RESOURCE_TYPE_SIGNATURES = [
  { pattern: /application\/json|application\/xml/i, type: 'API Endpoint', confidence: 90, contentTypeCheck: true },
  { pattern: /<form[^>]*method|<input[^>]*type="password"/i, type: 'Web Application', confidence: 80 },
  { pattern: /add-to-cart|checkout|shopping-cart/i, type: 'E-commerce', confidence: 85 },
  { pattern: /<article|<blog|published|author/i, type: 'Blog/Article', confidence: 80 },
  { pattern: /documentation|docs|guide|tutorial/i, type: 'Documentation', confidence: 80 },
  { pattern: /<app-root|data-reactroot|__next/i, type: 'SPA', confidence: 90 },
];

function detectPlatform(context: ScanContext): PlatformInfo {
  const detected: PlatformInfo[] = [];
  const headersStr = Object.entries(context.headers).map(([k, v]) => `${k}: ${v}`).join('\n');

  for (const sig of PLATFORM_SIGNATURES) {
    const source = (sig as any).headerCheck ? headersStr : context.body;
    const match = source.match(sig.pattern);
    
    if (match) {
      const existing = detected.find(p => p.name === sig.name);
      if (existing) {
        existing.confidence = Math.min(100, existing.confidence + 5);
        existing.indicators.push(match[0].substring(0, 40));
      } else {
        detected.push({
          name: sig.name,
          category: sig.category,
          confidence: sig.confidence,
          indicators: [match[0].substring(0, 40)]
        });
      }
    }
  }

  detected.sort((a, b) => b.confidence - a.confidence);
  return detected[0] || { name: 'Unknown', category: 'Unknown', confidence: 0, indicators: [] };
}

function detectResourceType(context: ScanContext): ResourceTypeInfo {
  const contentType = context.headers['content-type'] || '';
  const detected: ResourceTypeInfo[] = [];

  for (const sig of RESOURCE_TYPE_SIGNATURES) {
    const source = (sig as any).contentTypeCheck ? contentType : context.body;
    if (sig.pattern.test(source)) {
      detected.push({
        type: sig.type,
        confidence: sig.confidence,
        indicators: [],
        description: `${sig.type} detected`
      });
    }
  }

  detected.sort((a, b) => b.confidence - a.confidence);
  return detected[0] || { type: 'Web Page', confidence: 50, indicators: [], description: 'Standard web page' };
}

// ═══════════════════════════════════════════════════════════════
// SCORING ENGINE
// ═══════════════════════════════════════════════════════════════

function calculateSecurityScore(findings: VulnerabilityFinding[]): number {
  const severityWeights = { critical: 30, high: 18, medium: 9, low: 3, info: 1 };
  
  let penalty = 0;
  const vulnerable = findings.filter(f => f.status === 'vulnerable');
  
  for (const finding of vulnerable) {
    const weight = severityWeights[finding.severity];
    const confidenceFactor = finding.confidence / 100;
    penalty += weight * confidenceFactor;
  }

  // Bonus for immune findings
  const immune = findings.filter(f => f.status === 'immune').length;
  const bonus = Math.min(10, immune * 0.5);

  const score = Math.max(0, Math.min(100, 100 - penalty + bonus));
  return Math.round(score * 10) / 10;
}

function getRiskLevel(score: number): string {
  if (score >= 90) return "Secure";
  if (score >= 75) return "Low Risk";
  if (score >= 50) return "Medium Risk";
  if (score >= 25) return "High Risk";
  return "Critical Risk";
}

function generateExecutiveSummary(findings: VulnerabilityFinding[], score: number, platform: string): string {
  const vulnerable = findings.filter(f => f.status === 'vulnerable');
  const immune = findings.filter(f => f.status === 'immune');
  const critical = vulnerable.filter(f => f.severity === 'critical').length;
  const high = vulnerable.filter(f => f.severity === 'high').length;
  const risk = getRiskLevel(score);

  let summary = `Security assessment complete. Risk Level: ${risk} (${score}/100). `;
  summary += `Platform: ${platform}. `;
  summary += `Found ${vulnerable.length} vulnerabilities and ${immune.length} properly configured security controls. `;
  
  if (critical > 0) summary += `⚠️ CRITICAL: ${critical} critical issues require immediate attention. `;
  if (high > 0) summary += `${high} high-severity issues should be addressed promptly. `;
  
  if (vulnerable.length === 0) {
    summary += `No significant vulnerabilities detected. Continue monitoring and maintaining security best practices.`;
  }

  return summary;
}

// ═══════════════════════════════════════════════════════════════
// MAIN HANDLER
// ═══════════════════════════════════════════════════════════════

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const startTime = Date.now();

  try {
    const { url } = await req.json();

    // Validate URL
    const validation = validateUrl(url);
    if (!validation.valid || !validation.url) {
      console.error(`[Scan] Invalid URL: ${validation.error}`);
      return new Response(
        JSON.stringify({ error: validation.error || 'Invalid URL' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const targetUrl = validation.url.toString();
    console.log(`[Scan] Starting: ${targetUrl}`);

    // Fetch with retry
    const { response, responseTime } = await fetchWithRetry(targetUrl, {
      method: 'GET',
      headers: {
        'User-Agent': CONFIG.USER_AGENT,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
      },
      redirect: 'follow',
    });

    // Extract response data
    const headers: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });

    let body = await response.text();
    if (body.length > CONFIG.MAX_BODY_SIZE) {
      body = body.substring(0, CONFIG.MAX_BODY_SIZE);
      console.log(`[Scan] Body truncated to ${CONFIG.MAX_BODY_SIZE} bytes`);
    }

    const finalUrl = response.url;
    const hostname = new URL(finalUrl).hostname;

    console.log(`[Scan] Fetched ${finalUrl} - Status: ${response.status}, Size: ${body.length}, Time: ${responseTime}ms`);

    // Build context
    const context: ScanContext = {
      url: targetUrl,
      finalUrl,
      headers,
      body,
      statusCode: response.status,
      responseTime,
      isHttps: finalUrl.startsWith('https://'),
      hostname,
    };

    // Run signature matching
    const findings: VulnerabilityFinding[] = [];
    const processedSignatures = new Set<string>();

    for (const signature of MERGED_SIGNATURES) {
      // Skip duplicates
      if (processedSignatures.has(signature.id)) continue;
      processedSignatures.add(signature.id);

      try {
        const result = matchSignature(signature, context);
        if (result) {
          findings.push(result);
        }
      } catch (error) {
        console.warn(`[Scan] Signature ${signature.id} failed: ${error}`);
      }
    }

    // Detect platform and resource type
    const platformInfo = detectPlatform(context);
    const resourceTypeInfo = detectResourceType(context);

    console.log(`[Scan] Platform: ${platformInfo.name}, Resource: ${resourceTypeInfo.type}, Findings: ${findings.length}`);

    // Calculate scores
    const vulnerableCount = findings.filter(f => f.status === 'vulnerable').length;
    const immuneCount = findings.filter(f => f.status === 'immune').length;
    const securityScore = calculateSecurityScore(findings);
    const riskLevel = getRiskLevel(securityScore);

    const severityCounts = {
      critical: findings.filter(f => f.severity === 'critical' && f.status === 'vulnerable').length,
      high: findings.filter(f => f.severity === 'high' && f.status === 'vulnerable').length,
      medium: findings.filter(f => f.severity === 'medium' && f.status === 'vulnerable').length,
      low: findings.filter(f => f.severity === 'low' && f.status === 'vulnerable').length,
      info: findings.filter(f => f.severity === 'info' && f.status === 'vulnerable').length,
    };

    const result = {
      scan_id: `SCAN-${Date.now()}-${Math.random().toString(36).substring(7)}`,
      target_url: targetUrl,
      final_url: finalUrl,
      timestamp: new Date().toISOString(),
      scan_duration_ms: Date.now() - startTime,
      findings,
      platform: {
        name: platformInfo.name,
        category: platformInfo.category,
        version: platformInfo.version || null,
        confidence: platformInfo.confidence,
        indicators: platformInfo.indicators.slice(0, 5),
      },
      resource_type: {
        type: resourceTypeInfo.type,
        confidence: resourceTypeInfo.confidence,
        description: resourceTypeInfo.description,
        indicators: resourceTypeInfo.indicators.slice(0, 5),
      },
      summary: {
        total_checks: processedSignatures.size,
        findings_count: findings.length,
        vulnerable_count: vulnerableCount,
        immune_count: immuneCount,
        ...severityCounts,
        security_score: securityScore,
        risk_level: riskLevel,
      },
      executive_summary: generateExecutiveSummary(findings, securityScore, platformInfo.name),
    };

    console.log(`[Scan] Complete - Score: ${securityScore}/100, Risk: ${riskLevel}, Duration: ${Date.now() - startTime}ms`);

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[Scan] Error after ${duration}ms:`, error);
    
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Scan failed',
        details: 'Unable to complete vulnerability scan. The target may be unreachable or blocking automated requests.',
        duration_ms: duration
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
