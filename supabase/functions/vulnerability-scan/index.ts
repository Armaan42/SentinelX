
import { HttpClient } from './core/client.ts';
import { ScanConfig, VulnerabilityFinding, CrawledUrl } from './core/types.ts';
import { Crawler } from './modules/crawler.ts';
import { HeadersScanner } from './modules/scanners/headers.ts';
import { SqliScanner } from './modules/scanners/sqli.ts';
import { XssScanner } from './modules/scanners/xss.ts';
import { InjectionScanner } from './modules/scanners/injection.ts';
import { CsrfScanner } from './modules/scanners/csrf.ts';

import { RedirectScanner } from './modules/scanners/redirect.ts';
import { AuthHandler } from './modules/auth.ts';
import { TimeBasedScanner } from './modules/scanners/time_based.ts';
import { AuthAdvancedScanner } from './modules/scanners/jwt_oauth.ts';
import { ApiScanner } from './modules/scanners/api_sec.ts';
import { NoSqlLdapScanner } from './modules/scanners/nosql_ldap.ts';
import { SsrfScanner } from './modules/scanners/ssrf.ts';

// Silence IDE error for Deno global
declare const Deno: any;

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const CONFIG: ScanConfig = {
  maxDepth: 2,
  maxPages: 10, // Limit pages to avoid timeout
  concurrency: 2,
  timeout: 20000, // 20s per request max
  userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
};

// ═══════════════════════════════════════════════════════════════
// SCORING & UTILS (PRESERVED)
// ═══════════════════════════════════════════════════════════════

function validateUrl(input: string): { valid: boolean; url?: URL; error?: string } {
  try {
    const trimmed = input.trim();
    if (!trimmed) return { valid: false, error: 'URL is empty' };

    let urlString = trimmed;
    if (!urlString.match(/^https?:\/\//i)) urlString = `https://${urlString}`;

    const url = new URL(urlString);
    if (!['http:', 'https:'].includes(url.protocol)) return { valid: false, error: 'Only HTTP/HTTPS allowed' };

    const hostname = url.hostname.toLowerCase();
    const blocked = [/^localhost$/, /^192\.168\./, /^127\./, /^10\./, /\.local$/, /\.internal$/];
    if (blocked.some(p => p.test(hostname))) return { valid: false, error: 'Local addresses blocked' };

    return { valid: true, url };
  } catch (e: any) {
    return { valid: false, error: e.message };
  }
}

function determineGradeCap(findings: VulnerabilityFinding[]): { maxScore: number; capReason: string } | null {
  const missingCSP = findings.some(f => f.title.includes('Missing Content-Security-Policy') && f.detection_type === 'header_missing');
  const missingHSTS = findings.some(f => f.title.includes('Missing Strict-Transport-Security') && f.detection_type === 'header_missing');
  const missingXFO = findings.some(f => f.title.includes('Missing X-Frame-Options') && f.detection_type === 'header_missing');
  const criticalVuln = findings.some(f => f.severity === 'critical' && f.status === 'vulnerable');

  if (criticalVuln) return { maxScore: 40, capReason: 'Critical vulnerability detected (Grade F)' };
  if (missingCSP) return { maxScore: 60, capReason: 'Missing Content-Security-Policy header (Capped at Grade D)' };
  if (missingXFO) return { maxScore: 60, capReason: 'Missing X-Frame-Options header (Capped at Grade D)' };
  if (missingHSTS) return { maxScore: 70, capReason: 'Missing Strict-Transport-Security header (Capped at Grade C)' };

  return null;
}

function calculateSecurityScore(findings: VulnerabilityFinding[]): number {
  const severityWeights = { critical: 40, high: 25, medium: 15, low: 5, info: 0 };
  let penalty = 0;

  findings.filter(f => f.status === 'vulnerable').forEach(f => {
    penalty += severityWeights[f.severity] * (f.confidence / 100);
  });

  // Partial penalty for unknown/unverified
  findings.filter(f => f.status === 'unknown').forEach(f => {
    penalty += (severityWeights[f.severity] * 0.2) * (f.confidence / 100);
  });

  const baseScore = Math.max(0, Math.min(100, 100 - penalty));
  const cap = determineGradeCap(findings);

  if (cap) return Math.min(baseScore, cap.maxScore);
  return Math.round(baseScore);
}

function getRiskLevel(score: number): string {
  if (score >= 90) return "Secure";
  if (score >= 75) return "Low Risk";
  if (score >= 50) return "Medium Risk";
  if (score >= 25) return "High Risk";
  return "Critical Risk";
}

function generateExecutiveSummary(findings: VulnerabilityFinding[], score: number): string {
  const vulnerable = findings.filter(f => f.status === 'vulnerable');
  const critical = vulnerable.filter(f => f.severity === 'critical').length;
  const high = vulnerable.filter(f => f.severity === 'high').length;
  const risk = getRiskLevel(score);

  let grade = 'F';
  if (score >= 95 && critical === 0 && high === 0) grade = 'A+';
  else if (score >= 90 && critical === 0 && high === 0) grade = 'A';
  else if (score >= 80 && critical === 0) grade = 'B';
  else if (score >= 70 && critical === 0) grade = 'C';
  else if (score >= 50) grade = 'D';

  let summary = `Security assessment complete. Grade: ${grade} (Score: ${score}/100, Risk: ${risk}). `;
  const cap = determineGradeCap(findings);
  if (cap && score <= cap.maxScore) summary += `Grade limited by: ${cap.capReason}. `;

  summary += `Found ${vulnerable.length} verified vulnerabilities. `;
  if (critical > 0) summary += `⚠️ CRITICAL: ${critical} critical issues require immediate attention. `;

  return summary;
}

// ═══════════════════════════════════════════════════════════════
// MAIN HANDLER
// ═══════════════════════════════════════════════════════════════

Deno.serve(async (req: Request) => {
  if (req.method === 'OPTIONS') return new Response(null, { headers: corsHeaders });

  const startTime = Date.now();
  try {
    const body = await req.json().catch(() => ({}));
    const { url, username, password } = body;
    const validation = validateUrl(url);
    if (!validation.valid || !validation.url) {
      return new Response(JSON.stringify({ error: validation.error }), { status: 400, headers: corsHeaders });
    }

    const targetUrl = validation.url.toString();
    console.log(`[Scan] Starting Active Scan for: ${targetUrl}`);

    // Initialize Core Systems
    const client = new HttpClient(CONFIG);

    // Auth Phase
    if (username && password) {
      const auth = new AuthHandler(client, CONFIG);
      const loggedIn = await auth.login(targetUrl + '/login', { username, password }); // Simple heuristic for now
      if (loggedIn) {
        console.log('[Scan] Authenticated scan enabled');
        client.setHeaders(auth.getSessionHeaders());
      }
    }

    const crawler = new Crawler(client, CONFIG);

    // Phase 1: Crawl
    console.log('[Scan] Phase 1: Crawling...');
    const crawledUrls = await crawler.crawl(targetUrl);
    console.log(`[Scan] Discovered ${crawledUrls.length} endpoints`);

    // Phase 2: Active Scanning
    console.log('[Scan] Phase 2: Active Scanning...');
    const findings: VulnerabilityFinding[] = [];
    const scanners = [
      new HeadersScanner(client, CONFIG),
      new SqliScanner(client, CONFIG),
      new XssScanner(client, CONFIG),
      new InjectionScanner(client, CONFIG),
      new CsrfScanner(client, CONFIG),
      new RedirectScanner(client, CONFIG),
      new TimeBasedScanner(client, CONFIG),
      new AuthAdvancedScanner(client, CONFIG),
      new ApiScanner(client, CONFIG),
      new NoSqlLdapScanner(client, CONFIG),
      new SsrfScanner(client, CONFIG)
    ];

    // Scan main URL first (most important)
    for (const scanner of scanners) {
      if (crawledUrls[0]) {
        const results = await scanner.scan(crawledUrls[0]);
        findings.push(...results);
      }
    }

    // Scan discovered endpoints (limit to top 3 for speed)
    for (const target of crawledUrls.slice(1, 4)) {
      // Skip headers scan for sub-pages (optimization)
      const subScanners = scanners.filter(s => !(s instanceof HeadersScanner));
      for (const scanner of subScanners) {
        const results = await scanner.scan(target);
        findings.push(...results);
      }
    }

    // Phase 3: Reporting
    const securityScore = calculateSecurityScore(findings);
    const riskLevel = getRiskLevel(securityScore);
    const executiveSummary = generateExecutiveSummary(findings, securityScore);

    // Summary counts
    const severityCounts = {
      critical: findings.filter(f => f.severity === 'critical' && f.status === 'vulnerable').length,
      high: findings.filter(f => f.severity === 'high' && f.status === 'vulnerable').length,
      medium: findings.filter(f => f.severity === 'medium' && f.status === 'vulnerable').length,
      low: findings.filter(f => f.severity === 'low' && f.status === 'vulnerable').length,
      info: findings.filter(f => f.severity === 'info' && f.status === 'vulnerable').length,
    };

    const result = {
      scan_id: `SCAN-${Date.now()}`,
      target_url: targetUrl,
      timestamp: new Date().toISOString(),
      findings,
      summary: {
        total_endpoints: crawledUrls.length,
        findings_count: findings.length,
        vulnerable_count: findings.filter(f => f.status === 'vulnerable').length,
        ...severityCounts,
        security_score: securityScore,
        risk_level: riskLevel,
      },
      executive_summary: executiveSummary,
      _debug: {
        crawled_urls: crawledUrls.map(c => c.url),
        scanners_run: ['Headers', 'SQLi', 'XSS', 'Injection', 'CSRF', 'Redirect', 'TimeBased', 'AuthAdvanced', 'API', 'NoSQL', 'SSRF']
      }
    };

    return new Response(JSON.stringify(result), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });

  } catch (error: any) {
    console.error(`[Scan] Fatal Error: ${error}`);
    return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: corsHeaders });
  }
});
