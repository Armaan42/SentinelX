import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { SIGNATURE_DATABASE, VulnerabilitySignature } from "./signatures.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// ═══════════════════════════════════════════════════════════════
// SIGNATURE DATABASE
// ═══════════════════════════════════════════════════════════════

interface VulnerabilitySignature {
  id: string;
  title: string;
  owasp_category: string;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  detection_type: 'header_missing' | 'header_value' | 'content_match' | 'tech_fingerprint' | 'behavior' | 'misconfiguration';
  pattern?: string | RegExp;
  header_name?: string;
  expected_value?: string | RegExp;
  negative_match?: boolean; // true if we're checking for ABSENCE
  confidence_base: number;
  recommendation: string;
  references: string[];
}

const SIGNATURE_DATABASE: VulnerabilitySignature[] = [
  // ─────────────────────────────────────────────────────────────
  // A01:2021 - Broken Access Control
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A01-001",
    title: "Directory Listing Enabled",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "medium",
    detection_type: "content_match",
    pattern: /Index of \//i,
    confidence_base: 90,
    recommendation: "Disable directory listing in web server configuration",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },
  {
    id: "SIG-A01-002",
    title: "Exposed Admin Panel",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "high",
    detection_type: "content_match",
    pattern: /(admin|administrator|control panel|dashboard|wp-admin)/i,
    confidence_base: 60,
    recommendation: "Implement proper authentication and restrict admin panel access",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },
  {
    id: "SIG-A01-003",
    title: "Missing Access-Control Headers",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "access-control-allow-origin",
    negative_match: true,
    confidence_base: 40,
    recommendation: "Implement proper CORS policies with restricted origins",
    references: ["https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"]
  },
  {
    id: "SIG-A01-004",
    title: "Wildcard CORS Configuration",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "high",
    detection_type: "header_value",
    header_name: "access-control-allow-origin",
    expected_value: "*",
    confidence_base: 95,
    recommendation: "Restrict CORS to specific trusted domains instead of wildcard",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A02:2021 - Cryptographic Failures
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A02-001",
    title: "Missing Strict-Transport-Security Header",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "high",
    detection_type: "header_missing",
    header_name: "strict-transport-security",
    negative_match: true,
    confidence_base: 85,
    recommendation: "Add HSTS header: Strict-Transport-Security: max-age=31536000; includeSubDomains; preload",
    references: ["https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"]
  },
  {
    id: "SIG-A02-002",
    title: "Weak HSTS Configuration",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "medium",
    detection_type: "header_value",
    header_name: "strict-transport-security",
    expected_value: /max-age=([0-9]+)/,
    confidence_base: 70,
    recommendation: "Set HSTS max-age to at least 31536000 (1 year)",
    references: ["https://hstspreload.org/"]
  },
  {
    id: "SIG-A02-003",
    title: "Insecure Cookie Configuration",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "medium",
    detection_type: "header_value",
    header_name: "set-cookie",
    expected_value: /(?!.*Secure)(?!.*HttpOnly)/,
    confidence_base: 75,
    recommendation: "Set Secure and HttpOnly flags on all cookies",
    references: ["https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A03:2021 - Injection
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A03-001",
    title: "Potential SQL Error Exposure",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /(SQL syntax|mysql_fetch|pg_query|ORA-[0-9]{5}|SQLite error|SQLSTATE)/i,
    confidence_base: 85,
    recommendation: "Implement proper error handling and never expose database errors to users",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },
  {
    id: "SIG-A03-002",
    title: "Stack Trace Exposure",
    owasp_category: "A03:2021 - Injection",
    severity: "medium",
    detection_type: "content_match",
    pattern: /(stack trace|at [A-Za-z0-9\.]+\.[A-Za-z]+\([^\)]+\)|Exception in thread|Traceback \(most recent call last\))/i,
    confidence_base: 90,
    recommendation: "Disable debug mode in production and implement custom error pages",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },
  {
    id: "SIG-A03-003",
    title: "Potential XSS Vulnerability",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /<script[^>]*>|javascript:|onerror=|onload=/i,
    confidence_base: 50,
    recommendation: "Implement Content Security Policy and proper input sanitization",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A04:2021 - Insecure Design
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A04-001",
    title: "Missing Content-Security-Policy",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "content-security-policy",
    negative_match: true,
    confidence_base: 70,
    recommendation: "Implement a strict Content Security Policy",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },
  {
    id: "SIG-A04-002",
    title: "Weak Content-Security-Policy",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_value",
    header_name: "content-security-policy",
    expected_value: /'unsafe-inline'|'unsafe-eval'|\*/,
    confidence_base: 65,
    recommendation: "Remove unsafe-inline, unsafe-eval, and wildcard sources from CSP",
    references: ["https://content-security-policy.com/"]
  },
  {
    id: "SIG-A04-003",
    title: "Missing X-Frame-Options",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "x-frame-options",
    negative_match: true,
    confidence_base: 75,
    recommendation: "Add X-Frame-Options: DENY or SAMEORIGIN to prevent clickjacking",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A05:2021 - Security Misconfiguration
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A05-001",
    title: "Server Version Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "server",
    expected_value: /(Apache|nginx|IIS|Tomcat|Express)\/[0-9\.]+/i,
    confidence_base: 90,
    recommendation: "Remove or obscure server version information",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-002",
    title: "X-Powered-By Header Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "x-powered-by",
    expected_value: /.+/,
    confidence_base: 85,
    recommendation: "Remove X-Powered-By header to prevent technology disclosure",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-003",
    title: "Missing X-Content-Type-Options",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "x-content-type-options",
    negative_match: true,
    confidence_base: 70,
    recommendation: "Add X-Content-Type-Options: nosniff to prevent MIME-sniffing",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-004",
    title: "Missing Referrer-Policy",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "referrer-policy",
    negative_match: true,
    confidence_base: 60,
    recommendation: "Implement Referrer-Policy: no-referrer or strict-origin-when-cross-origin",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-005",
    title: "Exposed Git Directory",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /\.git\/(config|HEAD|index)/,
    confidence_base: 95,
    recommendation: "Block access to .git directory immediately",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-006",
    title: "Exposed Environment File",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /\.env|DB_PASSWORD|API_KEY|SECRET_KEY/i,
    confidence_base: 95,
    recommendation: "Remove .env and configuration files from web-accessible directories",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A06:2021 - Vulnerable and Outdated Components
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A06-001",
    title: "WordPress Detection",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "info",
    detection_type: "tech_fingerprint",
    pattern: /wp-content|wp-includes|wordpress/i,
    confidence_base: 95,
    recommendation: "Ensure WordPress and all plugins are up to date",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },
  {
    id: "SIG-A06-002",
    title: "jQuery Detected (Potential Outdated Version)",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "low",
    detection_type: "tech_fingerprint",
    pattern: /jquery[.-]([0-9\.]+)/i,
    confidence_base: 70,
    recommendation: "Update jQuery to the latest version (3.6.0+)",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },
  {
    id: "SIG-A06-003",
    title: "PHP Version Disclosure",
    owasp_category: "A06:2021 - Vulnerable and Outdated Components",
    severity: "medium",
    detection_type: "header_value",
    header_name: "x-powered-by",
    expected_value: /PHP\/([0-9\.]+)/i,
    confidence_base: 90,
    recommendation: "Remove PHP version header and ensure PHP is updated to latest secure version",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A07:2021 - Identification and Authentication Failures
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A07-001",
    title: "Weak Session Cookie Configuration",
    owasp_category: "A07:2021 - Identification and Authentication Failures",
    severity: "high",
    detection_type: "header_value",
    header_name: "set-cookie",
    expected_value: /session|auth|token/i,
    confidence_base: 60,
    recommendation: "Ensure session cookies have Secure, HttpOnly, and SameSite flags",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },
  {
    id: "SIG-A07-002",
    title: "Login Page Detected Without Rate Limiting",
    owasp_category: "A07:2021 - Identification and Authentication Failures",
    severity: "medium",
    detection_type: "content_match",
    pattern: /(login|signin|sign in|username|password)/i,
    confidence_base: 50,
    recommendation: "Implement rate limiting and account lockout mechanisms",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A08:2021 - Software and Data Integrity Failures
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A08-001",
    title: "Missing Subresource Integrity",
    owasp_category: "A08:2021 - Software and Data Integrity Failures",
    severity: "medium",
    detection_type: "content_match",
    pattern: /<script[^>]+src=["']https?:\/\/[^"']+["'](?![^>]*integrity=)/i,
    confidence_base: 70,
    recommendation: "Add Subresource Integrity (SRI) hashes to external scripts",
    references: ["https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A09:2021 - Security Logging and Monitoring Failures
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A09-001",
    title: "Debug Mode Enabled",
    owasp_category: "A09:2021 - Security Logging and Monitoring Failures",
    severity: "high",
    detection_type: "content_match",
    pattern: /(DEBUG|TRACE|<pre>|var_dump|print_r)/i,
    confidence_base: 80,
    recommendation: "Disable debug mode in production environments",
    references: ["https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/"]
  },

  // ─────────────────────────────────────────────────────────────
  // A10:2021 - Server-Side Request Forgery (SSRF)
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-A10-001",
    title: "Potential SSRF via URL Parameter",
    owasp_category: "A10:2021 - Server-Side Request Forgery",
    severity: "high",
    detection_type: "behavior",
    pattern: /[?&](url|uri|redirect|callback|proxy|fetch)=/i,
    confidence_base: 40,
    recommendation: "Validate and whitelist allowed URLs, use URL parsing libraries",
    references: ["https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/"]
  },

  // ─────────────────────────────────────────────────────────────
  // Additional Security Checks
  // ─────────────────────────────────────────────────────────────
  {
    id: "SIG-EXT-001",
    title: "Missing Permissions-Policy",
    owasp_category: "Extended Security Headers",
    severity: "low",
    detection_type: "header_missing",
    header_name: "permissions-policy",
    negative_match: true,
    confidence_base: 50,
    recommendation: "Implement Permissions-Policy to control browser features",
    references: ["https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy"]
  },
  {
    id: "SIG-EXT-002",
    title: "Clickjacking Protection Missing",
    owasp_category: "Extended Security Headers",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "x-frame-options",
    negative_match: true,
    confidence_base: 75,
    recommendation: "Add X-Frame-Options: DENY or implement frame-ancestors in CSP",
    references: ["https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"]
  },
  {
    id: "SIG-EXT-003",
    title: "Robots.txt Information Disclosure",
    owasp_category: "Information Disclosure",
    severity: "info",
    detection_type: "content_match",
    pattern: /Disallow:.*\/(admin|private|secret|internal|confidential)/i,
    confidence_base: 60,
    recommendation: "Review robots.txt for sensitive path disclosures",
    references: ["https://www.robotstxt.org/"]
  },
  {
    id: "SIG-EXT-004",
    title: "Default Error Page Detected",
    owasp_category: "Information Disclosure",
    severity: "low",
    detection_type: "content_match",
    pattern: /(404 Not Found|403 Forbidden|500 Internal Server Error|Apache.*default page|Welcome to nginx)/i,
    confidence_base: 70,
    recommendation: "Implement custom error pages",
    references: ["https://owasp.org/www-project-web-security-testing-guide/"]
  },
];

// ═══════════════════════════════════════════════════════════════
// SIGNATURE MATCHING ENGINE WITH FALSE POSITIVE REDUCTION
// ═══════════════════════════════════════════════════════════════

interface ScanContext {
  url: string;
  headers: Record<string, string>;
  body: string;
  statusCode: number;
}

interface VulnerabilityFinding {
  id: string;
  title: string;
  owasp_category: string;
  status: 'immune' | 'vulnerable' | 'unknown';
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  evidence: string[];
  recommendation: string;
  references: string[];
  explanation?: string; // Detailed explanation of why this status was assigned
  confidence_factors?: string[]; // Factors that affected the confidence score
}

// Trusted domains that typically have proper security (reduce false positives)
const TRUSTED_DOMAINS = [
  'google.com', 'microsoft.com', 'apple.com', 'amazon.com', 'facebook.com',
  'cloudflare.com', 'github.com', 'linkedin.com', 'twitter.com', 'netflix.com',
  'mozilla.org', 'youtube.com', 'bing.com', 'yahoo.com'
];

function isTrustedDomain(url: string): boolean {
  try {
    const hostname = new URL(url).hostname.toLowerCase();
    return TRUSTED_DOMAINS.some(domain => hostname.includes(domain));
  } catch {
    return false;
  }
}

// Check if a script tag has a nonce (CSP-compliant, not a vulnerability)
function hasScriptNonce(body: string): boolean {
  return /<script[^>]*nonce=/i.test(body);
}

// Check if content looks like minified JavaScript (not debug mode)
function isMinifiedJs(content: string): boolean {
  // Minified JS has very long lines, few newlines relative to content
  const avgLineLength = content.length / (content.split('\n').length || 1);
  return avgLineLength > 500;
}

// Better cookie security analysis
function analyzeCookieSecurity(cookieHeader: string): { secure: boolean; httpOnly: boolean; sameSite: boolean } {
  const lower = cookieHeader.toLowerCase();
  return {
    secure: lower.includes('secure'),
    httpOnly: lower.includes('httponly'),
    sameSite: lower.includes('samesite')
  };
}

// Check if HSTS header is properly configured
function isHstsSecure(hstsHeader: string): { secure: boolean; maxAge: number } {
  const maxAgeMatch = hstsHeader.match(/max-age=(\d+)/i);
  const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1]) : 0;
  return {
    secure: maxAge >= 31536000, // At least 1 year
    maxAge
  };
}

function matchSignature(signature: VulnerabilitySignature, context: ScanContext): VulnerabilityFinding | null {
  const evidence: string[] = [];
  const confidenceFactors: string[] = [];
  let matched = false;
  let confidence = signature.confidence_base;
  let explanation = '';
  const trusted = isTrustedDomain(context.url);
  const hostname = new URL(context.url).hostname;

  // Normalize headers to lowercase keys
  const normalizedHeaders: Record<string, string> = {};
  Object.keys(context.headers).forEach(key => {
    normalizedHeaders[key.toLowerCase()] = context.headers[key];
  });

  // Track base confidence
  confidenceFactors.push(`Base confidence: ${signature.confidence_base}% (signature default)`);

  switch (signature.detection_type) {
    case 'header_missing': {
      const headerExists = signature.header_name && normalizedHeaders[signature.header_name.toLowerCase()];
      if (signature.negative_match) {
        // Check if header is missing
        if (!headerExists) {
          matched = true;
          evidence.push(`Header '${signature.header_name}' is not present in the HTTP response`);
          explanation = `The security header '${signature.header_name}' was not found in the server's HTTP response headers. This header helps protect against specific attack vectors.`;
          
          // Reduce confidence for trusted domains (they often handle security differently)
          if (trusted) {
            const reduction = 30;
            confidence = Math.max(20, confidence - reduction);
            confidenceFactors.push(`-${reduction}% for trusted domain (${hostname}) - major platforms often implement security at infrastructure level`);
            explanation += ` However, ${hostname} is a known trusted platform that may implement equivalent protections through other means (CDN, infrastructure-level security, or alternative headers).`;
          }
        }
      } else {
        // Check if header exists
        if (headerExists) {
          matched = true;
          evidence.push(`Header '${signature.header_name}' is present: ${normalizedHeaders[signature.header_name.toLowerCase()].substring(0, 100)}`);
          explanation = `The header '${signature.header_name}' was detected with a value that may indicate a security concern.`;
        }
      }
      break;
    }

    case 'header_value': {
      if (!signature.header_name) break;
      const headerValue = normalizedHeaders[signature.header_name.toLowerCase()];
      
      if (headerValue && signature.expected_value) {
        // Special handling for cookies - better analysis
        if (signature.header_name.toLowerCase() === 'set-cookie') {
          const cookieSecurity = analyzeCookieSecurity(headerValue);
          const securityFlags = [];
          if (cookieSecurity.secure) securityFlags.push('Secure');
          if (cookieSecurity.httpOnly) securityFlags.push('HttpOnly');
          if (cookieSecurity.sameSite) securityFlags.push('SameSite');
          
          // Check what the signature is looking for
          if (signature.id === 'SIG-A02-003' || signature.id.includes('Secure')) {
            if (cookieSecurity.secure) {
              return {
                id: signature.id,
                title: signature.title,
                owasp_category: signature.owasp_category,
                status: 'immune',
                severity: signature.severity,
                confidence: 95,
                evidence: [`Cookie properly configured with Secure flag`],
                recommendation: 'Cookie security is properly implemented.',
                references: signature.references,
                explanation: `The cookie includes the 'Secure' flag, which ensures it is only transmitted over HTTPS connections. This prevents the cookie from being intercepted over unencrypted connections.${securityFlags.length > 1 ? ` Additional security flags present: ${securityFlags.join(', ')}.` : ''}`,
                confidence_factors: ['95% - Secure flag explicitly detected in Set-Cookie header']
              };
            } else {
              matched = true;
              evidence.push(`Cookie missing Secure flag: ${headerValue.substring(0, 80)}`);
              explanation = `The Set-Cookie header does not include the 'Secure' flag. Without this flag, the cookie could be transmitted over unencrypted HTTP connections, making it vulnerable to interception.`;
            }
          } else if (signature.id === 'SIG-A02-004' || signature.id.includes('HttpOnly')) {
            if (cookieSecurity.httpOnly) {
              return {
                id: signature.id,
                title: signature.title,
                owasp_category: signature.owasp_category,
                status: 'immune',
                severity: signature.severity,
                confidence: 95,
                evidence: [`Cookie properly configured with HttpOnly flag`],
                recommendation: 'Cookie security is properly implemented.',
                references: signature.references,
                explanation: `The cookie includes the 'HttpOnly' flag, which prevents JavaScript from accessing the cookie. This is a critical defense against XSS attacks that attempt to steal session cookies.`,
                confidence_factors: ['95% - HttpOnly flag explicitly detected in Set-Cookie header']
              };
            } else {
              matched = true;
              evidence.push(`Cookie missing HttpOnly flag`);
              explanation = `The Set-Cookie header does not include the 'HttpOnly' flag. This means client-side JavaScript can access the cookie, which could allow attackers to steal it via XSS attacks.`;
            }
          } else {
            // Generic cookie check - only flag if BOTH flags are missing
            if (!cookieSecurity.secure && !cookieSecurity.httpOnly) {
              matched = true;
              evidence.push(`Cookie missing both Secure and HttpOnly flags: ${headerValue.substring(0, 80)}`);
              explanation = `The cookie lacks both 'Secure' and 'HttpOnly' flags. This means the cookie can be transmitted over unencrypted connections AND accessed by JavaScript, significantly increasing attack surface.`;
            } else {
              return null; // Has at least one security flag
            }
          }
          break;
        }
        
        // Special handling for HSTS
        if (signature.header_name.toLowerCase() === 'strict-transport-security') {
          const hstsAnalysis = isHstsSecure(headerValue);
          const maxAgeYears = (hstsAnalysis.maxAge / 31536000).toFixed(2);
          
          if (signature.id === 'SIG-A02-002') { // Weak HSTS
            if (hstsAnalysis.secure) {
              return {
                id: signature.id,
                title: 'HSTS Properly Configured',
                owasp_category: signature.owasp_category,
                status: 'immune',
                severity: 'info',
                confidence: 95,
                evidence: [`HSTS max-age is ${hstsAnalysis.maxAge} seconds (${maxAgeYears} years)`],
                recommendation: 'HSTS is properly configured with an appropriate max-age value.',
                references: signature.references,
                explanation: `The Strict-Transport-Security header is configured with a max-age of ${hstsAnalysis.maxAge} seconds (approximately ${maxAgeYears} years). This exceeds the recommended minimum of 1 year (31,536,000 seconds), ensuring browsers will enforce HTTPS connections for an extended period.`,
                confidence_factors: ['95% - HSTS max-age exceeds 1 year minimum requirement']
              };
            } else {
              matched = true;
              evidence.push(`HSTS max-age is ${hstsAnalysis.maxAge} seconds (${maxAgeYears} years) - below recommended 1 year`);
              explanation = `The HSTS max-age value of ${hstsAnalysis.maxAge} seconds (${maxAgeYears} years) is below the recommended minimum of 31,536,000 seconds (1 year). A shorter duration means browsers may revert to HTTP connections sooner than desired.`;
              confidenceFactors.push(`HSTS present but with short max-age (${maxAgeYears} years)`);
            }
          }
          break;
        }

        if (typeof signature.expected_value === 'string') {
          if (headerValue.includes(signature.expected_value)) {
            matched = true;
            evidence.push(`Header '${signature.header_name}' contains: ${headerValue.substring(0, 100)}`);
            explanation = `The header '${signature.header_name}' contains the value '${signature.expected_value}' which may indicate a security misconfiguration.`;
          }
        } else if (signature.expected_value instanceof RegExp) {
          const regexMatch = headerValue.match(signature.expected_value);
          if (regexMatch) {
            matched = true;
            evidence.push(`Header '${signature.header_name}' matched pattern: ${headerValue.substring(0, 100)}`);
            explanation = `The header '${signature.header_name}' matches a known insecure pattern. The matched value was: "${regexMatch[0]}".`;
          }
        }
      }
      break;
    }

    case 'content_match': {
      if (signature.pattern) {
        const regex = typeof signature.pattern === 'string' 
          ? new RegExp(signature.pattern, 'i') 
          : signature.pattern;
        
        // Special handling to reduce false positives
        
        // XSS detection - don't flag scripts with nonces (they're CSP-compliant)
        if (signature.id === 'SIG-A03-003' || signature.title.includes('XSS')) {
          if (hasScriptNonce(context.body)) {
            return {
              id: signature.id,
              title: 'CSP Nonce Protected Scripts',
              owasp_category: signature.owasp_category,
              status: 'immune',
              severity: 'info',
              confidence: 90,
              evidence: ['Scripts are protected with CSP nonces'],
              recommendation: 'Continue using CSP nonces to protect inline scripts.',
              references: signature.references,
              explanation: `The page uses Content Security Policy (CSP) nonces to protect inline scripts. CSP nonces are cryptographically random values that must match between the CSP header and script tags, preventing unauthorized script execution. This is a modern best practice that effectively mitigates XSS attacks while allowing necessary inline scripts.`,
              confidence_factors: ['90% - CSP nonce attribute detected on script tags, indicating proper XSS protection']
            };
          }
        }
        
        // Debug mode detection - exclude minified JavaScript
        if (signature.id === 'SIG-A09-001' || signature.title.includes('Debug')) {
          const realDebugPatterns = [
            { pattern: /var_dump\s*\(/i, name: 'PHP var_dump()' },
            { pattern: /print_r\s*\(/i, name: 'PHP print_r()' },
            { pattern: /console\.(log|debug)\s*\([^)]*\)/i, name: 'console.log/debug' },
            { pattern: /debugger;/i, name: 'JavaScript debugger statement' },
            { pattern: /\bDEBUG\s*=\s*true/i, name: 'DEBUG flag enabled' },
            { pattern: /\bTRACE\s*=\s*true/i, name: 'TRACE flag enabled' },
            { pattern: /<pre>[\s\S]*?(error|exception|stack)/i, name: 'Error output in <pre> tags' },
          ];
          
          const detectedPatterns: string[] = [];
          realDebugPatterns.forEach(({ pattern, name }) => {
            if (pattern.test(context.body)) {
              detectedPatterns.push(name);
            }
          });
          
          if (detectedPatterns.length === 0) {
            if (isMinifiedJs(context.body)) {
              // Return null for minified JS - not a real debug indicator
              return null;
            }
          }
          
          if (detectedPatterns.length > 0) {
            matched = true;
            evidence.push(`Debug patterns detected: ${detectedPatterns.join(', ')}`);
            explanation = `Actual debug code patterns were found in the page source: ${detectedPatterns.join(', ')}. These patterns indicate that debug functionality may be enabled in production, which can leak sensitive information to attackers.`;
            confidence = 85;
            confidenceFactors.push(`85% - Real debug patterns detected (${detectedPatterns.length} patterns found)`);
          } else {
            // No real debug patterns, check if it's just minified code false positive
            const contentMatch = context.body.match(regex);
            if (contentMatch && isMinifiedJs(context.body)) {
              return null; // Minified JS, not real debug mode
            }
          }
          break;
        }
        
        // Login page detection - reduce false positives for normal sites
        if (signature.id === 'SIG-A07-002' || signature.title.includes('Login')) {
          const hasLoginForm = /<form[^>]*action[^>]*>/i.test(context.body) && 
                              /(password|login|signin)/i.test(context.body);
          if (!hasLoginForm) {
            return null;
          }
          
          // Check for rate limiting headers
          const hasRateLimiting = normalizedHeaders['x-ratelimit-limit'] || 
                                  normalizedHeaders['retry-after'] ||
                                  normalizedHeaders['x-rate-limit-limit'];
          
          if (hasRateLimiting) {
            const rateLimitHeader = normalizedHeaders['x-ratelimit-limit'] || 
                                   normalizedHeaders['x-rate-limit-limit'] || 
                                   normalizedHeaders['retry-after'];
            return {
              id: signature.id,
              title: 'Login Page with Rate Limiting',
              owasp_category: signature.owasp_category,
              status: 'immune',
              severity: 'info',
              confidence: 80,
              evidence: [`Rate limiting detected: ${rateLimitHeader}`],
              recommendation: 'Rate limiting is properly implemented.',
              references: signature.references,
              explanation: `A login form was detected, but the server implements rate limiting (detected via HTTP headers). Rate limiting is a key defense against brute-force password attacks, limiting the number of login attempts an attacker can make.`,
              confidence_factors: ['80% - Rate limiting headers present in response']
            };
          }
          
          if (hasLoginForm) {
            matched = true;
            evidence.push('Login form detected without visible rate limiting headers');
            explanation = `A login form was detected on this page, but no rate limiting headers were found in the HTTP response. While rate limiting may be implemented at the application level (not visible via headers), the absence of these headers suggests brute-force protection may be missing.`;
            
            if (trusted) {
              const reduction = 25;
              confidence = Math.max(25, confidence - reduction);
              confidenceFactors.push(`-${reduction}% for trusted domain - ${hostname} likely implements rate limiting at infrastructure level`);
              explanation += ` However, ${hostname} is a trusted platform that almost certainly implements rate limiting through other means not visible in headers.`;
            }
          }
        }
        
        // Admin panel detection - reduce false positives
        if (signature.id === 'SIG-A01-002' || signature.title.includes('Admin')) {
          const isActualAdminPage = /\/(admin|administrator|wp-admin|control-panel)\/?$/i.test(context.url);
          if (!isActualAdminPage) {
            return null;
          }
          matched = true;
          evidence.push(`Admin panel endpoint detected: ${context.url}`);
          explanation = `The URL path suggests this is an administrative interface. Admin panels are high-value targets for attackers and should have strong authentication, IP restrictions, and ideally be on a separate subdomain.`;
        }
        
        // Generic content match if no special handling applied
        if (!matched && !explanation) {
          const contentMatch = context.body.match(regex);
          if (contentMatch) {
            matched = true;
            const matchStart = Math.max(0, (contentMatch.index || 0) - 30);
            const matchEnd = Math.min(context.body.length, (contentMatch.index || 0) + contentMatch[0].length + 30);
            const snippet = context.body.substring(matchStart, matchEnd);
            evidence.push(`Pattern matched: ...${snippet}...`);
            explanation = `The page content matches a known vulnerability signature pattern. The matched content suggests potential security concerns related to ${signature.owasp_category}.`;
            
            if (trusted) {
              const reduction = 20;
              confidence = Math.max(20, confidence - reduction);
              confidenceFactors.push(`-${reduction}% for trusted domain - pattern may be benign on ${hostname}`);
            }
          }
        }
      }
      break;
    }

    case 'tech_fingerprint': {
      if (signature.pattern) {
        const regex = typeof signature.pattern === 'string' 
          ? new RegExp(signature.pattern, 'i') 
          : signature.pattern;
        
        const bodyMatch = context.body.match(regex);
        const urlMatch = context.url.match(regex);
        const techMatch = bodyMatch || urlMatch;
        
        if (techMatch) {
          matched = true;
          const detectedTech = techMatch[0];
          evidence.push(`Technology detected: ${detectedTech}`);
          explanation = `The technology "${detectedTech}" was identified on this site. This is primarily informational - knowing the technology stack helps identify potential version-specific vulnerabilities. Ensure all components are kept up to date with security patches.`;
          
          if (trusted) {
            const reduction = 20;
            confidence = Math.max(30, confidence - reduction);
            confidenceFactors.push(`-${reduction}% for trusted domain - ${hostname} likely maintains updated software`);
          }
        }
      }
      break;
    }

    case 'behavior': {
      if (signature.pattern) {
        const regex = typeof signature.pattern === 'string' 
          ? new RegExp(signature.pattern, 'i') 
          : signature.pattern;
        
        const urlMatch = context.url.match(regex);
        if (urlMatch) {
          matched = true;
          evidence.push(`URL behavior pattern: ${urlMatch[0]}`);
          explanation = `The URL contains a pattern "${urlMatch[0]}" that may indicate potentially risky functionality. This pattern is associated with ${signature.title.toLowerCase()}. Review whether proper validation and security controls are in place for this functionality.`;
        }
      }
      break;
    }

    case 'misconfiguration': {
      if (signature.pattern) {
        const regex = typeof signature.pattern === 'string' 
          ? new RegExp(signature.pattern, 'i') 
          : signature.pattern;
        
        const configMatch = context.body.match(regex);
        if (configMatch) {
          matched = true;
          evidence.push(`Misconfiguration pattern: ${configMatch[0]}`);
          explanation = `A potential security misconfiguration was detected: "${configMatch[0]}". Misconfigurations often occur when default settings are not changed or security hardening steps are skipped during deployment.`;
        }
      }
      break;
    }
  }

  if (matched) {
    return {
      id: signature.id,
      title: signature.title,
      owasp_category: signature.owasp_category,
      status: 'vulnerable',
      severity: signature.severity,
      confidence,
      evidence,
      recommendation: signature.recommendation,
      references: signature.references,
      explanation: explanation || `This finding indicates a potential ${signature.severity} severity security issue related to ${signature.owasp_category}.`,
      confidence_factors: confidenceFactors
    };
  }

  // Return immune status for header checks that passed
  if (signature.detection_type === 'header_missing' && signature.negative_match && !matched) {
    const headerValue = normalizedHeaders[signature.header_name?.toLowerCase() || ''];
    return {
      id: signature.id,
      title: signature.title,
      owasp_category: signature.owasp_category,
      status: 'immune',
      severity: signature.severity,
      confidence: 95,
      evidence: [`Header '${signature.header_name}' is present${headerValue ? `: ${headerValue.substring(0, 80)}` : ''}`],
      recommendation: `The ${signature.header_name} header is properly configured.`,
      references: signature.references,
      explanation: `The security header '${signature.header_name}' is present and configured. This header provides protection against ${signature.title.toLowerCase().replace('missing ', '')}.`,
      confidence_factors: ['95% - Header explicitly detected in HTTP response']
    };
  }

  return null;
}

// ═══════════════════════════════════════════════════════════════
// SECURITY SCORING ENGINE
// ═══════════════════════════════════════════════════════════════

function calculateSecurityScore(findings: VulnerabilityFinding[]): number {
  const severityWeights = {
    critical: 25,
    high: 15,
    medium: 8,
    low: 3,
    info: 1,
  };

  let totalPenalty = 0;
  const vulnerableFindings = findings.filter(f => f.status === 'vulnerable');

  vulnerableFindings.forEach(finding => {
    const weight = severityWeights[finding.severity];
    const confidenceFactor = finding.confidence / 100;
    totalPenalty += weight * confidenceFactor;
  });

  const maxPossiblePenalty = 100;
  const score = Math.max(0, 100 - (totalPenalty / maxPossiblePenalty) * 100);
  
  return Math.round(score * 10) / 10; // Round to 1 decimal
}

function getRiskLevel(score: number): string {
  if (score >= 90) return "Secure";
  if (score >= 70) return "Low Risk";
  if (score >= 50) return "Medium Risk";
  if (score >= 30) return "High Risk";
  return "Critical Risk";
}

function generateExecutiveSummary(findings: VulnerabilityFinding[], score: number): string {
  const vulnerable = findings.filter(f => f.status === 'vulnerable');
  const critical = vulnerable.filter(f => f.severity === 'critical').length;
  const high = vulnerable.filter(f => f.severity === 'high').length;
  const medium = vulnerable.filter(f => f.severity === 'medium').length;
  const riskLevel = getRiskLevel(score);

  return `Security assessment completed. Overall risk level: ${riskLevel} (${score}/100). 
Identified ${vulnerable.length} vulnerabilities: ${critical} critical, ${high} high, ${medium} medium severity. 
${critical > 0 ? 'URGENT: Critical vulnerabilities require immediate attention. ' : ''}
${high > 0 ? 'High-priority vulnerabilities should be addressed promptly. ' : ''}
Review detailed findings and implement recommended remediations.`;
}

// ═══════════════════════════════════════════════════════════════
// MAIN SCAN HANDLER
// ═══════════════════════════════════════════════════════════════

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { url } = await req.json();

    if (!url) {
      return new Response(
        JSON.stringify({ error: 'URL parameter is required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`[Vulnerability Scan] Starting scan for: ${url}`);

    // Fetch target URL
    const targetResponse = await fetch(url, {
      method: 'GET',
      headers: {
        'User-Agent': 'SentinelX-Scanner/1.0 (Vulnerability Assessment)',
      },
      redirect: 'follow',
    });

    const headers: Record<string, string> = {};
    targetResponse.headers.forEach((value, key) => {
      headers[key] = value;
    });

    const body = await targetResponse.text();
    const statusCode = targetResponse.status;

    console.log(`[Vulnerability Scan] Fetched ${url} - Status: ${statusCode}, Body length: ${body.length}`);

    // Build scan context
    const context: ScanContext = {
      url,
      headers,
      body,
      statusCode,
    };

    // Run all signatures
    const findings: VulnerabilityFinding[] = [];
    
    for (const signature of SIGNATURE_DATABASE) {
      const result = matchSignature(signature, context);
      if (result) {
        findings.push(result);
      }
    }

    console.log(`[Vulnerability Scan] Found ${findings.length} findings`);

    // Calculate severity distribution
    const severityCounts = {
      critical: findings.filter(f => f.severity === 'critical' && f.status === 'vulnerable').length,
      high: findings.filter(f => f.severity === 'high' && f.status === 'vulnerable').length,
      medium: findings.filter(f => f.severity === 'medium' && f.status === 'vulnerable').length,
      low: findings.filter(f => f.severity === 'low' && f.status === 'vulnerable').length,
      info: findings.filter(f => f.severity === 'info' && f.status === 'vulnerable').length,
    };

    const vulnerableCount = findings.filter(f => f.status === 'vulnerable').length;
    const immuneCount = findings.filter(f => f.status === 'immune').length;
    const securityScore = calculateSecurityScore(findings);
    const riskLevel = getRiskLevel(securityScore);
    const executiveSummary = generateExecutiveSummary(findings, securityScore);

    const result = {
      scan_id: `SCAN-${Date.now()}`,
      target_url: url,
      timestamp: new Date().toISOString(),
      findings,
      summary: {
        total_checks: SIGNATURE_DATABASE.length,
        findings_count: findings.length,
        vulnerable_count: vulnerableCount,
        immune_count: immuneCount,
        ...severityCounts,
        security_score: securityScore,
        risk_level: riskLevel,
      },
      executive_summary: executiveSummary,
    };

    console.log(`[Vulnerability Scan] Completed - Score: ${securityScore}/100, Risk: ${riskLevel}`);

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('[Vulnerability Scan] Error:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        details: 'Failed to complete vulnerability scan'
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
