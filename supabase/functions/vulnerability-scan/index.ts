import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// ═══════════════════════════════════════════════════════════════
// CONFIGURATION & CONSTANTS
// ═══════════════════════════════════════════════════════════════

const CONFIG = {
  MAX_BODY_SIZE: 5 * 1024 * 1024,
  REQUEST_TIMEOUT: 15000,
  MAX_REDIRECTS: 5,
  USER_AGENT: 'SentinelX-Scanner/2.0 (Security Assessment Tool)',
  RETRY_ATTEMPTS: 2,
  RETRY_DELAY: 1000,
};

// ═══════════════════════════════════════════════════════════════
// HSTS PRELOAD LIST - Sites that have HSTS at browser level
// ═══════════════════════════════════════════════════════════════

const HSTS_PRELOAD_DOMAINS = new Set([
  'google.com', 'www.google.com', 'accounts.google.com', 'mail.google.com',
  'facebook.com', 'www.facebook.com', 'twitter.com', 'x.com',
  'paypal.com', 'www.paypal.com', 'github.com', 'www.github.com',
  'dropbox.com', 'www.dropbox.com', 'stripe.com', 'www.stripe.com',
  'mozilla.org', 'www.mozilla.org', 'microsoft.com', 'www.microsoft.com',
  'apple.com', 'www.apple.com', 'amazon.com', 'www.amazon.com',
  'youtube.com', 'www.youtube.com', 'linkedin.com', 'www.linkedin.com',
  'instagram.com', 'www.instagram.com', 'netflix.com', 'www.netflix.com',
  'cloudflare.com', 'www.cloudflare.com', 'slack.com', 'www.slack.com',
]);

// Trusted enterprise domains with known good security practices
const ENTERPRISE_DOMAINS = new Set([
  'google.com', 'microsoft.com', 'apple.com', 'amazon.com', 'facebook.com',
  'cloudflare.com', 'github.com', 'linkedin.com', 'twitter.com', 'netflix.com',
  'mozilla.org', 'youtube.com', 'stripe.com', 'paypal.com', 'salesforce.com',
  'zoom.us', 'slack.com', 'atlassian.com', 'dropbox.com', 'adobe.com',
  'oracle.com', 'ibm.com', 'cisco.com', 'intel.com', 'nvidia.com',
  'reddit.com', 'spotify.com', 'twitch.tv', 'instagram.com', 'x.com',
]);

// ═══════════════════════════════════════════════════════════════
// VALIDATED SIGNATURE DATABASE - Only high-confidence detections
// ═══════════════════════════════════════════════════════════════

interface VulnerabilitySignature {
  id: string;
  title: string;
  owasp_category: string;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  detection_type: 'header_missing' | 'header_value' | 'content_match' | 'tech_fingerprint';
  header_name?: string;
  pattern?: RegExp;
  validator?: (context: ScanContext, match?: RegExpMatchArray) => ValidationResult;
  confidence_base: number;
  recommendation: string;
  references: string[];
  skip_for_trusted?: boolean;
  requires_context?: boolean;
}

interface ValidationResult {
  valid: boolean;
  reason?: string;
  adjusted_confidence?: number;
  evidence?: string;
}

interface ScanContext {
  url: string;
  finalUrl: string;
  headers: Record<string, string>;
  body: string;
  statusCode: number;
  responseTime: number;
  isHttps: boolean;
  hostname: string;
  isEnterprise: boolean;
  isHstsPreloaded: boolean;
}

interface VulnerabilityFinding {
  id: string;
  title: string;
  owasp_category: string;
  status: 'immune' | 'vulnerable' | 'info';
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  evidence: string[];
  recommendation: string;
  references: string[];
  explanation?: string;
}

// ═══════════════════════════════════════════════════════════════
// VALIDATION FUNCTIONS - Ensure findings are real
// ═══════════════════════════════════════════════════════════════

function validateHstsMissing(context: ScanContext): ValidationResult {
  // Check HSTS preload list first
  if (context.isHstsPreloaded) {
    return { valid: false, reason: 'Domain is in HSTS preload list' };
  }
  
  // Enterprise domains typically have HSTS at infrastructure level
  if (context.isEnterprise) {
    return { valid: false, reason: 'Enterprise domain has infrastructure-level HSTS' };
  }
  
  return { valid: true, evidence: 'HSTS header not present and domain not preloaded' };
}

function validateCspMissing(context: ScanContext): ValidationResult {
  // Check for CSP in meta tag
  const metaCsp = /<meta[^>]+http-equiv=["']Content-Security-Policy["'][^>]*content=["']([^"']+)["']/i;
  if (metaCsp.test(context.body)) {
    return { valid: false, reason: 'CSP is defined via meta tag' };
  }
  
  // Check for CSP-related nonces (indicates CSP is active)
  if (/<script[^>]+nonce=["'][^"']+["']/i.test(context.body)) {
    return { valid: false, reason: 'CSP nonces detected, indicating active CSP' };
  }
  
  return { valid: true };
}

function validateXssVulnerability(context: ScanContext, match?: RegExpMatchArray): ValidationResult {
  if (!match) return { valid: false };
  
  const matchedContent = match[0];
  
  // Skip if it's a legitimate external script with crossorigin
  if (/crossorigin/i.test(matchedContent)) {
    return { valid: false, reason: 'Script has crossorigin attribute' };
  }
  
  // Skip if script has integrity attribute (SRI)
  if (/integrity=/i.test(matchedContent)) {
    return { valid: false, reason: 'Script has SRI integrity check' };
  }
  
  // Skip if it's from a CDN
  if (/cdn\.|cdnjs|jsdelivr|unpkg|googleapis|gstatic/i.test(matchedContent)) {
    return { valid: false, reason: 'Script is from trusted CDN' };
  }
  
  // Skip inline scripts with nonce
  if (/nonce=/i.test(matchedContent)) {
    return { valid: false, reason: 'Script has CSP nonce' };
  }
  
  return { valid: true, evidence: matchedContent.substring(0, 100) };
}

function validateSqlError(context: ScanContext, match?: RegExpMatchArray): ValidationResult {
  if (!match) return { valid: false };
  
  // Must be in an error-like context, not just documentation
  const matchIndex = match.index || 0;
  const surrounding = context.body.substring(
    Math.max(0, matchIndex - 100),
    Math.min(context.body.length, matchIndex + 200)
  );
  
  // Skip if it looks like documentation or code examples
  if (/<code|<pre|syntax|example|tutorial|documentation/i.test(surrounding)) {
    return { valid: false, reason: 'Appears to be documentation or code example' };
  }
  
  return { valid: true, evidence: match[0] };
}

function validateDirectoryListing(context: ScanContext): ValidationResult {
  // Must have actual directory listing indicators
  const hasIndex = /Index of \/[a-zA-Z]/i.test(context.body);
  const hasParentDir = /Parent Directory/i.test(context.body);
  const hasFileList = /<a href="[^"]+\/">/i.test(context.body);
  
  if (hasIndex && (hasParentDir || hasFileList)) {
    return { valid: true, evidence: 'Directory listing with file/folder links detected' };
  }
  
  return { valid: false, reason: 'Not a real directory listing' };
}

function validateGitExposure(context: ScanContext): ValidationResult {
  // Must have actual git config content
  const hasGitConfig = /\[core\]\s*\n\s*repositoryformatversion/i.test(context.body);
  const hasGitHead = /ref:\s*refs\/heads\//i.test(context.body);
  
  if (hasGitConfig || hasGitHead) {
    return { valid: true, evidence: 'Git repository configuration exposed' };
  }
  
  return { valid: false, reason: 'Not actual git directory content' };
}

function validateEnvExposure(context: ScanContext): ValidationResult {
  // Must have actual env variable format, not just mentions
  const envPattern = /^[A-Z_]+=.+$/m;
  const hasDbPassword = /DB_PASSWORD\s*=\s*["']?[^"'\s]+["']?/i.test(context.body);
  const hasApiKey = /API_KEY\s*=\s*["']?[A-Za-z0-9_-]{20,}["']?/i.test(context.body);
  
  if (hasDbPassword || hasApiKey) {
    return { valid: true, evidence: 'Environment variables with secrets exposed' };
  }
  
  return { valid: false, reason: 'No actual secrets exposed' };
}

function validatePhpInfo(context: ScanContext): ValidationResult {
  // Must have actual phpinfo output markers
  const hasPhpInfo = /PHP Version|php\.ini|Configuration File/i.test(context.body);
  const hasModules = /Loaded Modules|Registered PHP Streams/i.test(context.body);
  
  if (hasPhpInfo && hasModules) {
    return { valid: true, evidence: 'Full phpinfo() output detected' };
  }
  
  return { valid: false, reason: 'Not actual phpinfo output' };
}

function validateStackTrace(context: ScanContext, match?: RegExpMatchArray): ValidationResult {
  if (!match) return { valid: false };
  
  const matchIndex = match.index || 0;
  const surrounding = context.body.substring(
    Math.max(0, matchIndex - 50),
    Math.min(context.body.length, matchIndex + 300)
  );
  
  // Skip if in comments or code blocks
  if (/<!--.*-->|<code|<pre|"stack"|'stack'|\\n/i.test(surrounding)) {
    return { valid: false, reason: 'Stack trace in code block or JSON' };
  }
  
  // Must have multiple lines of stack trace
  const stackLines = (surrounding.match(/at [A-Za-z0-9_$]+\./g) || []).length;
  if (stackLines >= 3) {
    return { valid: true, evidence: 'Production stack trace with multiple frames' };
  }
  
  return { valid: false, reason: 'Insufficient stack trace evidence' };
}

// ═══════════════════════════════════════════════════════════════
// REFINED SIGNATURE DATABASE
// ═══════════════════════════════════════════════════════════════

const SIGNATURES: VulnerabilitySignature[] = [
  // ══════ A02: Cryptographic Failures ══════
  {
    id: "SIG-A02-001",
    title: "Missing HSTS Header",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "high",
    detection_type: "header_missing",
    header_name: "strict-transport-security",
    validator: validateHstsMissing,
    confidence_base: 90,
    skip_for_trusted: true,
    recommendation: "Add Strict-Transport-Security header with max-age of at least 1 year",
    references: ["https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"]
  },
  {
    id: "SIG-A02-002",
    title: "Weak HSTS Configuration",
    owasp_category: "A02:2021 - Cryptographic Failures",
    severity: "medium",
    detection_type: "header_value",
    header_name: "strict-transport-security",
    pattern: /max-age=(\d+)/i,
    validator: (context, match) => {
      if (!match || !match[1]) return { valid: false };
      const maxAge = parseInt(match[1]);
      if (maxAge < 31536000) {
        return { valid: true, evidence: `HSTS max-age is only ${maxAge} seconds (${Math.round(maxAge/86400)} days)` };
      }
      return { valid: false, reason: 'HSTS max-age is sufficient' };
    },
    confidence_base: 85,
    recommendation: "Set HSTS max-age to at least 31536000 (1 year)",
    references: ["https://hstspreload.org/"]
  },

  // ══════ A03: Injection ══════
  {
    id: "SIG-A03-001",
    title: "SQL Error Disclosure",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /(SQL syntax.*MySQL|pg_query\(\)|ORA-[0-9]{5}:|SQLSTATE\[|sqlite3?\.OperationalError)/i,
    validator: validateSqlError,
    confidence_base: 95,
    recommendation: "Implement proper error handling and never expose database errors",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },
  {
    id: "SIG-A03-002",
    title: "Stack Trace Exposure",
    owasp_category: "A03:2021 - Injection",
    severity: "high",
    detection_type: "content_match",
    pattern: /(at [A-Za-z0-9_$]+\.[A-Za-z0-9_$]+\([^)]*:[0-9]+\)|Traceback \(most recent call last\):)/i,
    validator: validateStackTrace,
    confidence_base: 90,
    recommendation: "Disable debug mode and implement custom error pages",
    references: ["https://owasp.org/Top10/A03_2021-Injection/"]
  },

  // ══════ A04: Insecure Design ══════
  {
    id: "SIG-A04-001",
    title: "Missing Content-Security-Policy",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "content-security-policy",
    validator: validateCspMissing,
    confidence_base: 75,
    skip_for_trusted: true,
    recommendation: "Implement a strict Content Security Policy",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },
  {
    id: "SIG-A04-002",
    title: "Unsafe CSP Directives",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_value",
    header_name: "content-security-policy",
    pattern: /'unsafe-inline'[^;]*script-src|script-src[^;]*'unsafe-inline'/i,
    validator: (context, match) => {
      if (!match) return { valid: false };
      // Check if nonces are also used (acceptable pattern)
      const csp = context.headers['content-security-policy'] || '';
      if (/'nonce-[^']+'/i.test(csp)) {
        return { valid: false, reason: 'Uses nonces alongside unsafe-inline' };
      }
      return { valid: true, evidence: 'CSP allows unsafe-inline without nonces' };
    },
    confidence_base: 80,
    recommendation: "Remove unsafe-inline from CSP or use nonces",
    references: ["https://content-security-policy.com/"]
  },
  {
    id: "SIG-A04-003",
    title: "Missing X-Frame-Options",
    owasp_category: "A04:2021 - Insecure Design",
    severity: "medium",
    detection_type: "header_missing",
    header_name: "x-frame-options",
    validator: (context) => {
      // Check for frame-ancestors in CSP
      const csp = context.headers['content-security-policy'] || '';
      if (/frame-ancestors/i.test(csp)) {
        return { valid: false, reason: 'CSP frame-ancestors provides equivalent protection' };
      }
      return { valid: true };
    },
    confidence_base: 75,
    skip_for_trusted: true,
    recommendation: "Add X-Frame-Options: DENY or SAMEORIGIN",
    references: ["https://owasp.org/Top10/A04_2021-Insecure_Design/"]
  },

  // ══════ A05: Security Misconfiguration ══════
  {
    id: "SIG-A05-001",
    title: "Server Version Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "server",
    pattern: /(Apache|nginx|IIS|Microsoft-IIS|LiteSpeed)\/[0-9]+\.[0-9]+/i,
    confidence_base: 90,
    recommendation: "Remove or obscure server version information",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-002",
    title: "X-Powered-By Header Disclosure",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_value",
    header_name: "x-powered-by",
    pattern: /(PHP|ASP\.NET|Express|Ruby|Python)[\s\/]?[0-9]*/i,
    confidence_base: 85,
    recommendation: "Remove X-Powered-By header",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-003",
    title: "Directory Listing Enabled",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "medium",
    detection_type: "content_match",
    pattern: /Index of \/[a-zA-Z]/i,
    validator: validateDirectoryListing,
    confidence_base: 95,
    recommendation: "Disable directory listing in server configuration",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-004",
    title: "Exposed Git Repository",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /\[core\]\s*\n?\s*repositoryformatversion|ref:\s*refs\/heads\//i,
    validator: validateGitExposure,
    confidence_base: 98,
    recommendation: "Block access to .git directory immediately",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-005",
    title: "Exposed Environment Variables",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "critical",
    detection_type: "content_match",
    pattern: /(DB_PASSWORD|DATABASE_URL|API_SECRET|PRIVATE_KEY|AWS_SECRET)\s*=\s*["']?[^\s"']{8,}/i,
    validator: validateEnvExposure,
    confidence_base: 95,
    recommendation: "Remove .env files from web-accessible directories",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-006",
    title: "Missing X-Content-Type-Options",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "x-content-type-options",
    confidence_base: 70,
    skip_for_trusted: true,
    recommendation: "Add X-Content-Type-Options: nosniff",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },
  {
    id: "SIG-A05-007",
    title: "Missing Referrer-Policy",
    owasp_category: "A05:2021 - Security Misconfiguration",
    severity: "low",
    detection_type: "header_missing",
    header_name: "referrer-policy",
    confidence_base: 60,
    skip_for_trusted: true,
    recommendation: "Add Referrer-Policy: strict-origin-when-cross-origin",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },

  // ══════ A06: Vulnerable Components ══════
  {
    id: "SIG-A06-001",
    title: "WordPress Detection",
    owasp_category: "A06:2021 - Vulnerable Components",
    severity: "info",
    detection_type: "tech_fingerprint",
    pattern: /wp-content\/|wp-includes\/|\/wp-json\//i,
    confidence_base: 95,
    recommendation: "Ensure WordPress core and all plugins are up to date",
    references: ["https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/"]
  },
  {
    id: "SIG-A06-002",
    title: "Outdated jQuery Version",
    owasp_category: "A06:2021 - Vulnerable Components",
    severity: "medium",
    detection_type: "tech_fingerprint",
    pattern: /jquery[.-](1\.[0-9]+|2\.[0-2])\.(min\.)?js/i,
    validator: (context, match) => {
      if (!match) return { valid: false };
      return { valid: true, evidence: `jQuery ${match[1]} detected - vulnerable to XSS` };
    },
    confidence_base: 85,
    recommendation: "Update jQuery to version 3.5.0 or later",
    references: ["https://snyk.io/vuln/npm:jquery"]
  },
  {
    id: "SIG-A06-003",
    title: "PHP Version Disclosure",
    owasp_category: "A06:2021 - Vulnerable Components",
    severity: "medium",
    detection_type: "header_value",
    header_name: "x-powered-by",
    pattern: /PHP\/([5-7]\.[0-3]|8\.0)/i,
    validator: (context, match) => {
      if (!match || !match[1]) return { valid: false };
      return { valid: true, evidence: `PHP ${match[1]} may have known vulnerabilities` };
    },
    confidence_base: 90,
    recommendation: "Update PHP to latest stable version and remove version header",
    references: ["https://www.php.net/supported-versions.php"]
  },
  {
    id: "SIG-A06-004",
    title: "Exposed phpinfo() Page",
    owasp_category: "A06:2021 - Vulnerable Components",
    severity: "high",
    detection_type: "content_match",
    pattern: /PHP Version.*<\/td><td class="v">[0-9]+\.[0-9]+/i,
    validator: validatePhpInfo,
    confidence_base: 98,
    recommendation: "Remove phpinfo() pages from production",
    references: ["https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"]
  },

  // ══════ A07: Authentication Failures ══════
  {
    id: "SIG-A07-001",
    title: "Session Cookie Missing Secure Flag",
    owasp_category: "A07:2021 - Authentication Failures",
    severity: "high",
    detection_type: "header_value",
    header_name: "set-cookie",
    pattern: /(session|sid|sess_|PHPSESSID|JSESSIONID|ASP\.NET_SessionId)/i,
    validator: (context, match) => {
      if (!match) return { valid: false };
      const cookie = context.headers['set-cookie'] || '';
      const hasSecure = /;\s*secure/i.test(cookie);
      const hasHttpOnly = /;\s*httponly/i.test(cookie);
      
      if (!hasSecure || !hasHttpOnly) {
        const missing = [];
        if (!hasSecure) missing.push('Secure');
        if (!hasHttpOnly) missing.push('HttpOnly');
        return { valid: true, evidence: `Session cookie missing: ${missing.join(', ')}` };
      }
      return { valid: false, reason: 'Session cookie properly secured' };
    },
    confidence_base: 90,
    recommendation: "Set Secure and HttpOnly flags on session cookies",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },
  {
    id: "SIG-A07-002",
    title: "Basic Auth Over HTTP",
    owasp_category: "A07:2021 - Authentication Failures",
    severity: "critical",
    detection_type: "header_value",
    header_name: "www-authenticate",
    pattern: /^Basic\s/i,
    validator: (context) => {
      if (!context.isHttps) {
        return { valid: true, evidence: 'Basic authentication over unencrypted HTTP' };
      }
      return { valid: false, reason: 'Using HTTPS' };
    },
    confidence_base: 95,
    recommendation: "Use HTTPS and consider stronger authentication",
    references: ["https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"]
  },

  // ══════ CORS Issues ══════
  {
    id: "SIG-CORS-001",
    title: "Wildcard CORS Policy",
    owasp_category: "A01:2021 - Broken Access Control",
    severity: "high",
    detection_type: "header_value",
    header_name: "access-control-allow-origin",
    pattern: /^\*$/,
    validator: (context) => {
      // Wildcard CORS is less concerning for truly public APIs
      const contentType = context.headers['content-type'] || '';
      if (/application\/json/i.test(contentType)) {
        return { valid: true, evidence: 'Wildcard CORS on API endpoint', adjusted_confidence: 85 };
      }
      // For regular HTML pages, it's less of an issue
      return { valid: true, evidence: 'Wildcard CORS policy', adjusted_confidence: 70 };
    },
    confidence_base: 80,
    recommendation: "Restrict CORS to specific trusted domains",
    references: ["https://owasp.org/Top10/A01_2021-Broken_Access_Control/"]
  },
];

// ═══════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════

function validateUrl(input: string): { valid: boolean; url?: URL; error?: string } {
  try {
    const trimmed = input.trim();
    if (!trimmed) return { valid: false, error: 'URL is empty' };

    let urlString = trimmed;
    if (!urlString.match(/^https?:\/\//i)) {
      urlString = `https://${urlString}`;
    }

    const url = new URL(urlString);
    if (!['http:', 'https:'].includes(url.protocol)) {
      return { valid: false, error: 'Only HTTP and HTTPS protocols are allowed' };
    }

    const hostname = url.hostname.toLowerCase();
    const blockedPatterns = [
      /^localhost$/i, /^127\./, /^10\./, /^192\.168\./, /^172\.(1[6-9]|2[0-9]|3[01])\./,
      /^169\.254\./, /^::1$/, /^0\.0\.0\.0$/, /\.local$/i, /\.internal$/i,
    ];

    for (const pattern of blockedPatterns) {
      if (pattern.test(hostname)) {
        return { valid: false, error: 'Cannot scan local or internal addresses' };
      }
    }

    return { valid: true, url };
  } catch (error) {
    return { valid: false, error: `Invalid URL format` };
  }
}

function isEnterpriseDomain(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  for (const domain of ENTERPRISE_DOMAINS) {
    if (lower === domain || lower.endsWith('.' + domain)) {
      return true;
    }
  }
  return false;
}

function isHstsPreloaded(hostname: string): boolean {
  const lower = hostname.toLowerCase();
  for (const domain of HSTS_PRELOAD_DOMAINS) {
    if (lower === domain || lower.endsWith('.' + domain)) {
      return true;
    }
  }
  return false;
}

async function fetchWithRetry(
  url: string,
  options: RequestInit,
  retries = CONFIG.RETRY_ATTEMPTS
): Promise<{ response: Response; responseTime: number }> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), CONFIG.REQUEST_TIMEOUT);

    try {
      const startTime = Date.now();
      const response = await fetch(url, { ...options, signal: controller.signal });
      const responseTime = Date.now() - startTime;
      clearTimeout(timeoutId);
      return { response, responseTime };
    } catch (error) {
      clearTimeout(timeoutId);
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt < retries) {
        await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (attempt + 1)));
      }
    }
  }

  throw lastError || new Error('Failed to fetch URL');
}

// ═══════════════════════════════════════════════════════════════
// SIGNATURE MATCHING WITH VALIDATION
// ═══════════════════════════════════════════════════════════════

function matchSignature(signature: VulnerabilitySignature, context: ScanContext): VulnerabilityFinding | null {
  const normalizedHeaders: Record<string, string> = {};
  Object.keys(context.headers).forEach(key => {
    normalizedHeaders[key.toLowerCase()] = context.headers[key];
  });

  // Skip low-priority checks for enterprise domains
  if (signature.skip_for_trusted && context.isEnterprise) {
    if (signature.severity === 'low' || signature.severity === 'info') {
      return null;
    }
  }

  let matched = false;
  let evidence: string[] = [];
  let match: RegExpMatchArray | undefined;
  let confidence = signature.confidence_base;

  switch (signature.detection_type) {
    case 'header_missing': {
      const headerValue = normalizedHeaders[signature.header_name?.toLowerCase() || ''];
      if (!headerValue) {
        matched = true;
        evidence.push(`Header '${signature.header_name}' is not present`);
      } else {
        // Header exists - mark as immune
        return {
          id: signature.id,
          title: signature.title.replace('Missing ', '') + ' Configured',
          owasp_category: signature.owasp_category,
          status: 'immune',
          severity: 'info',
          confidence: 95,
          evidence: [`Header '${signature.header_name}' is present`],
          recommendation: `${signature.header_name} header is properly configured.`,
          references: signature.references,
        };
      }
      break;
    }

    case 'header_value': {
      const headerValue = normalizedHeaders[signature.header_name?.toLowerCase() || ''];
      if (headerValue && signature.pattern) {
        match = headerValue.match(signature.pattern);
        if (match) {
          matched = true;
          evidence.push(`Header '${signature.header_name}' matches pattern`);
        }
      }
      break;
    }

    case 'content_match': {
      if (signature.pattern) {
        match = context.body.match(signature.pattern);
        if (match) {
          matched = true;
          evidence.push(`Content matches signature pattern`);
        }
      }
      break;
    }

    case 'tech_fingerprint': {
      if (signature.pattern) {
        match = context.body.match(signature.pattern) || context.finalUrl.match(signature.pattern);
        if (match) {
          matched = true;
          evidence.push(`Technology fingerprint detected`);
        }
      }
      break;
    }
  }

  if (!matched) return null;

  // Run validator if present
  if (signature.validator) {
    const validationResult = signature.validator(context, match);
    
    if (!validationResult.valid) {
      console.log(`[Scan] Signature ${signature.id} failed validation: ${validationResult.reason}`);
      return null;
    }
    
    if (validationResult.evidence) {
      evidence = [validationResult.evidence];
    }
    
    if (validationResult.adjusted_confidence !== undefined) {
      confidence = validationResult.adjusted_confidence;
    }
  }

  // Apply enterprise domain confidence reduction
  if (context.isEnterprise && signature.severity !== 'critical') {
    confidence = Math.max(30, confidence - 25);
  }

  return {
    id: signature.id,
    title: signature.title,
    owasp_category: signature.owasp_category,
    status: 'vulnerable',
    severity: signature.severity,
    confidence: Math.round(confidence),
    evidence,
    recommendation: signature.recommendation,
    references: signature.references,
    explanation: `Verified ${signature.severity} severity finding.`,
  };
}

// ═══════════════════════════════════════════════════════════════
// PLATFORM DETECTION
// ═══════════════════════════════════════════════════════════════

interface PlatformInfo {
  name: string;
  category: string;
  confidence: number;
}

function detectPlatform(context: ScanContext): PlatformInfo {
  const patterns = [
    { pattern: /wp-content\/|wp-includes\/|\/wp-json\//i, name: 'WordPress', category: 'CMS', confidence: 95 },
    { pattern: /Shopify\.theme|cdn\.shopify/i, name: 'Shopify', category: 'E-commerce', confidence: 95 },
    { pattern: /__NEXT_DATA__|_next\//i, name: 'Next.js', category: 'Framework', confidence: 95 },
    { pattern: /ng-version|angular\//i, name: 'Angular', category: 'Framework', confidence: 90 },
    { pattern: /__NUXT__|_nuxt\//i, name: 'Nuxt.js', category: 'Framework', confidence: 95 },
    { pattern: /data-reactroot|react-dom/i, name: 'React', category: 'Framework', confidence: 80 },
    { pattern: /vue\.js|v-bind:|v-on:/i, name: 'Vue.js', category: 'Framework', confidence: 85 },
  ];

  const headersStr = Object.entries(context.headers).map(([k, v]) => `${k}: ${v}`).join('\n');

  for (const sig of patterns) {
    if (sig.pattern.test(context.body) || sig.pattern.test(headersStr)) {
      return { name: sig.name, category: sig.category, confidence: sig.confidence };
    }
  }

  return { name: 'Unknown', category: 'Unknown', confidence: 0 };
}

// ═══════════════════════════════════════════════════════════════
// SCORING ENGINE
// ═══════════════════════════════════════════════════════════════

function calculateSecurityScore(findings: VulnerabilityFinding[]): number {
  const severityWeights = { critical: 25, high: 15, medium: 8, low: 3, info: 0 };
  
  let penalty = 0;
  const vulnerable = findings.filter(f => f.status === 'vulnerable');
  
  for (const finding of vulnerable) {
    const weight = severityWeights[finding.severity];
    const confidenceFactor = finding.confidence / 100;
    penalty += weight * confidenceFactor;
  }

  const immune = findings.filter(f => f.status === 'immune').length;
  const bonus = Math.min(15, immune * 1.5);

  const score = Math.max(0, Math.min(100, 100 - penalty + bonus));
  return Math.round(score);
}

function getRiskLevel(score: number): string {
  if (score >= 90) return "Secure";
  if (score >= 75) return "Low Risk";
  if (score >= 50) return "Medium Risk";
  if (score >= 25) return "High Risk";
  return "Critical Risk";
}

// ═══════════════════════════════════════════════════════════════
// MAIN HANDLER
// ═══════════════════════════════════════════════════════════════

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const startTime = Date.now();

  try {
    const { url } = await req.json();

    const validation = validateUrl(url);
    if (!validation.valid || !validation.url) {
      return new Response(
        JSON.stringify({ error: validation.error || 'Invalid URL' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const targetUrl = validation.url.toString();
    console.log(`[Scan] Starting: ${targetUrl}`);

    const { response, responseTime } = await fetchWithRetry(targetUrl, {
      method: 'GET',
      headers: {
        'User-Agent': CONFIG.USER_AGENT,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
      },
      redirect: 'follow',
    });

    const headers: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });

    let body = await response.text();
    if (body.length > CONFIG.MAX_BODY_SIZE) {
      body = body.substring(0, CONFIG.MAX_BODY_SIZE);
    }

    const finalUrl = response.url;
    const hostname = new URL(finalUrl).hostname;

    console.log(`[Scan] Fetched ${finalUrl} - Status: ${response.status}, Size: ${body.length}b, Time: ${responseTime}ms`);

    const context: ScanContext = {
      url: targetUrl,
      finalUrl,
      headers,
      body,
      statusCode: response.status,
      responseTime,
      isHttps: finalUrl.startsWith('https://'),
      hostname,
      isEnterprise: isEnterpriseDomain(hostname),
      isHstsPreloaded: isHstsPreloaded(hostname),
    };

    // Run signature matching
    const findings: VulnerabilityFinding[] = [];

    for (const signature of SIGNATURES) {
      try {
        const result = matchSignature(signature, context);
        if (result) {
          findings.push(result);
        }
      } catch (error) {
        console.warn(`[Scan] Signature ${signature.id} error: ${error}`);
      }
    }

    // Detect platform
    const platformInfo = detectPlatform(context);

    // Calculate scores
    const vulnerableCount = findings.filter(f => f.status === 'vulnerable').length;
    const immuneCount = findings.filter(f => f.status === 'immune').length;
    const securityScore = calculateSecurityScore(findings);
    const riskLevel = getRiskLevel(securityScore);

    const severityCounts = {
      critical: findings.filter(f => f.severity === 'critical' && f.status === 'vulnerable').length,
      high: findings.filter(f => f.severity === 'high' && f.status === 'vulnerable').length,
      medium: findings.filter(f => f.severity === 'medium' && f.status === 'vulnerable').length,
      low: findings.filter(f => f.severity === 'low' && f.status === 'vulnerable').length,
      info: findings.filter(f => f.severity === 'info' && f.status === 'vulnerable').length,
    };

    const result = {
      scan_id: `SCAN-${Date.now()}-${Math.random().toString(36).substring(7)}`,
      target_url: targetUrl,
      final_url: finalUrl,
      timestamp: new Date().toISOString(),
      scan_duration_ms: Date.now() - startTime,
      findings,
      platform: {
        name: platformInfo.name,
        category: platformInfo.category,
        confidence: platformInfo.confidence,
      },
      summary: {
        total_checks: SIGNATURES.length,
        findings_count: findings.length,
        vulnerable_count: vulnerableCount,
        immune_count: immuneCount,
        ...severityCounts,
        security_score: securityScore,
        risk_level: riskLevel,
      },
      executive_summary: `Security Score: ${securityScore}/100 (${riskLevel}). Found ${vulnerableCount} issues and ${immuneCount} properly configured controls.`,
    };

    console.log(`[Scan] Complete - Score: ${securityScore}/100, Risk: ${riskLevel}, Findings: ${findings.length}`);

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error(`[Scan] Error:`, error);
    
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Scan failed',
        details: 'Unable to complete vulnerability scan.',
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
