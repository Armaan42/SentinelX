import { BaseScanner } from './active-base.ts';
import { CrawledUrl, VulnerabilityFinding } from '../../core/types.ts';

export class NoSqlLdapScanner extends BaseScanner {
    async scan(target: CrawledUrl): Promise<VulnerabilityFinding[]> {
        const findings: VulnerabilityFinding[] = [];

        for (const param of target.params) {
            // 1. NoSQL Injection (MongoDB focus)
            // Payload: parameter[$ne]=nothing (server-side: finds everything not equal to 'nothing', bypassing auth)
            // We can't easily inject object keys via simple query params in standard fetch without specialized encoding,
            // but many frameworks parse foo[$ne]=bar.

            const nosqlPayloads = [
                { key: `${param}[$ne]`, val: 'nothing', type: 'MongoDB' },
                { key: `${param}[$gt]`, val: '', type: 'MongoDB' },
                { key: param, val: '{"$ne": null}', type: 'JSON Injection' } // If raw JSON body usage
            ];

            for (const test of nosqlPayloads) {
                try {
                    const url = new URL(target.url);
                    url.searchParams.delete(param);
                    url.searchParams.set(test.key, test.val);

                    const { response } = await this.client.get(url.toString());
                    const body = await response.text();

                    // Detection: Error messages or Behavioral Bypass (hard to detect generically without baseline)
                    // We focus on known error patterns for now.
                    if (body && (body.includes('MongoError') || body.includes('CastError'))) {
                        findings.push({
                            id: `NOSQL-${Date.now()}`,
                            title: `NoSQL Injection (${test.type})`,
                            owasp_category: 'A03:2021 - Injection',
                            severity: 'high',
                            status: 'vulnerable',
                            detection_type: 'sqli', // Map to sqli grouping
                            confidence: 90,
                            evidence: [`Input triggering error: ${test.key}=${test.val}`, `Response fragment: ${body.substring(0, 100)}...`],
                            recommendation: 'Sanitize inputs and avoid passing user input directly to NoSQL query builders.',
                            references: ['https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf'],
                            affected_url: target.url,
                            param
                        });
                    }
                } catch { }
            }

            // 2. LDAP Injection
            // Payloads often break filters: * ) ( |
            const ldapPayloads = ['*', ')(uid=*))(|(uid=*'];
            for (const payload of ldapPayloads) {
                try {
                    const url = new URL(target.url);
                    url.searchParams.set(param, payload);
                    const { response } = await this.client.get(url.toString());
                    const body = await response.text();

                    if (body && (body.includes('LDAPException') || body.includes('com.sun.jndi.ldap'))) {
                        findings.push({
                            id: `LDAP-${Date.now()}`,
                            title: 'LDAP Injection',
                            owasp_category: 'A03:2021 - Injection',
                            severity: 'high',
                            status: 'vulnerable',
                            detection_type: 'sqli',
                            confidence: 90,
                            evidence: [`Input triggering error: ${payload}`, `Response fragment: ${body.substring(0, 100)}...`],
                            recommendation: 'Use LDAP encoding functions or parameterized LDAP queries.',
                            references: ['https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html'],
                            affected_url: target.url,
                            param
                        });
                    }
                } catch { }
            }
        }
        return findings;
    }
}
