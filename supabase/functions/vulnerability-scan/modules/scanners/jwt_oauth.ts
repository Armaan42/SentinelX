import { BaseScanner } from './active-base.ts';
import { CrawledUrl, VulnerabilityFinding } from '../../core/types.ts';

export class AuthAdvancedScanner extends BaseScanner {
    async scan(target: CrawledUrl): Promise<VulnerabilityFinding[]> {
        const findings: VulnerabilityFinding[] = [];

        // 1. JWT Analysis (if present in headers or params)
        // We check headers from the CLIENT (auth handler) if available, or params
        // Since we don't have direct access to client's session headers here easily without passing them,
        // we look for tokens in URL params (common in email links) or response bodies (captured during crawl).

        // Check URL params for JWT-like strings
        for (const param of target.params) {
            const val = new URL(target.url).searchParams.get(param);
            if (val && /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/.test(val)) {
                this.analyzeJwt(val, target.url, param, findings);
            }
        }

        // 2. OAuth Testing
        if (target.url.includes('oauth') || target.url.includes('oidc')) {
            const urlObj = new URL(target.url);
            const redirectUri = urlObj.searchParams.get('redirect_uri');
            if (redirectUri) {
                // Test Open Redirect on OAuth
                const testUrl = new URL(target.url);
                testUrl.searchParams.set('redirect_uri', 'https://evil.com');
                try {
                    const { response } = await this.client.fetch(testUrl.toString(), { method: 'GET', redirect: 'manual' });
                    if (response.headers.get('location')?.includes('evil.com')) {
                        findings.push({
                            id: `OAUTH-REDIRECT-${Date.now()}`,
                            title: 'OAuth Open Redirect',
                            owasp_category: 'A01:2021 - Broken Access Control',
                            severity: 'high',
                            status: 'vulnerable',
                            detection_type: 'misconfiguration',
                            confidence: 90,
                            evidence: ['OAuth redirect_uri parameter accepts arbitrary domains'],
                            recommendation: 'Whitelist allowed redirect_uris on the authorization server.',
                            references: ['https://oauth.net/2/security-best-practices/'],
                            affected_url: target.url
                        });
                    }
                } catch { }
            }
        }

        return findings;
    }

    private analyzeJwt(token: string, url: string, param: string, findings: VulnerabilityFinding[]) {
        try {
            const parts = token.split('.');
            if (parts.length !== 3) return;

            const header = JSON.parse(atob(parts[0]));
            const payload = JSON.parse(atob(parts[1]));

            // Check 1: Weak Algorithm
            if (header.alg === 'none' || header.alg === 'HS256') { // HS256 isn't inherrently weak but often weak-key prone
                // We flag 'none' as Critical, HS256 as Info/Low (check for weak secret later)
                if (header.alg === 'none') {
                    findings.push({
                        id: `JWT-NONE-${Date.now()}`,
                        title: 'JWT None Algorithm Supported',
                        owasp_category: 'A02:2021 - Cryptographic Failures',
                        severity: 'critical',
                        status: 'vulnerable',
                        detection_type: 'misconfiguration',
                        confidence: 100,
                        evidence: [`JWT Parameter '${param}' accepts tokens with 'alg': 'none'`],
                        recommendation: 'Disable "none" algorithm support in JWT library.',
                        references: ['https://jwt.io/introduction/'],
                        affected_url: url
                    });
                }
            }

            // Check 2: Sensitive Data in Payload
            const sensitiveKeys = ['password', 'secret', 'ssn', 'credit_card', 'email'];
            const exposed = Object.keys(payload).filter(k => sensitiveKeys.some(s => k.toLowerCase().includes(s)));
            if (exposed.length > 0) {
                findings.push({
                    id: `JWT-SENSITIVE-${Date.now()}`,
                    title: 'Sensitive Data in JWT Payload',
                    owasp_category: 'A04:2021 - Insecure Design',
                    severity: 'medium',
                    status: 'vulnerable',
                    detection_type: 'content_match', // Using content_match instead of info_disclosure
                    confidence: 100,
                    evidence: [`JWT Payload contains: ${exposed.join(', ')}`],
                    recommendation: 'Do not store sensitive data in JWTs (they are just base64 encoded).',
                    references: ['https://jwt.io/'],
                    affected_url: url
                });
            }
        } catch { }
    }
}
