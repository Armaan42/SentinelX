import { BaseScanner } from './active-base.ts';
import { CrawledUrl, VulnerabilityFinding } from '../../core/types.ts';

export class SsrfScanner extends BaseScanner {
    async scan(target: CrawledUrl): Promise<VulnerabilityFinding[]> {
        const findings: VulnerabilityFinding[] = [];

        // Heuristic: Identify potential SSRF parameters
        // e.g., ?url=, ?feed=, ?source=, ?proxy=, ?redirect=
        const suspectParams = ['url', 'uri', 'link', 'src', 'source', 'feed', 'host', 'proxy', 'target', 'dest', 'path', 'data', 'reference', 'site', 'html', 'val', 'value', 'return', 'page'];

        // Filter params that match our suspect list
        const paramsToTest = target.params.filter(p => suspectParams.some(s => p.toLowerCase().includes(s)));

        for (const param of paramsToTest) {
            // Payloads
            const payloads = [
                { name: 'AWS Metadata', val: 'http://169.254.169.254/latest/meta-data/' },
                { name: 'GCP Metadata', val: 'http://metadata.google.internal/computeMetadata/v1/' },
                { name: 'Azure Metadata', val: 'http://169.254.169.254/metadata/instance?api-version=2021-02-01' },
                { name: 'Localhost', val: 'http://127.0.0.1:80' },
                { name: 'Localhost (Alternative)', val: 'http://localhost:22' },
                { name: 'Orcale Metadata', val: 'http://192.0.0.192/latest/' }
            ];

            for (const test of payloads) {
                try {
                    const url = new URL(target.url);
                    url.searchParams.set(param, test.val);

                    // We use a short timeout because internal/metadata services usually respond instantly or time out fast.
                    // We wrap client.get if needed or just rely on global timeout.
                    const { response } = await this.client.get(url.toString());
                    const body = await response.text();

                    let confirmed = false;

                    // Check AWS
                    if (test.name === 'AWS Metadata' && body.includes('instance-id')) confirmed = true;
                    // Check GCP
                    if (test.name === 'GCP Metadata' && response.headers.get('Metadata-Flavor') === 'Google') confirmed = true;
                    // Check Generic
                    if (test.name.includes('Localhost') && (body.includes('SSH-2.0') || body.includes('apache') || body.includes('nginx'))) confirmed = true;

                    if (confirmed) {
                        findings.push({
                            id: `SSRF-${Date.now()}`,
                            title: `Severe SSRF (${test.name})`,
                            owasp_category: 'A10:2021 - Server-Side Request Forgery (SSRF)',
                            severity: 'critical',
                            status: 'vulnerable',
                            detection_type: 'rce', // SSRF often leads to RCE
                            confidence: 100,
                            evidence: [`Parameter '${param}' exposed internal metadata`, `Response fragment: ${body.substring(0, 50)}...`],
                            recommendation: 'Validate and sanitize all URLs provided by users. Use a whitelist of allowed domains.',
                            references: ['https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/'],
                            affected_url: target.url,
                            param,
                            payload: test.val
                        });

                        // Stop testing this param if we found critical SSRF
                        break;
                    }
                } catch { }
            }
        }
        return findings;
    }
}
