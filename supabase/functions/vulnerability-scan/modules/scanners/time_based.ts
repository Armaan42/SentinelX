import { BaseScanner } from './active-base.ts';
import { CrawledUrl, VulnerabilityFinding } from '../../core/types.ts';

export class TimeBasedScanner extends BaseScanner {
    async scan(target: CrawledUrl): Promise<VulnerabilityFinding[]> {
        const findings: VulnerabilityFinding[] = [];
        const BASELINE_SAMPLES = 3;
        const DELAY_SECONDS = 2; // Short delay for Lite versions (Serverless constraint)
        const DELAY_MS = DELAY_SECONDS * 1000;
        const THRESHOLD_MS = DELAY_MS * 0.8; // Allow 20% variance

        if (target.params.length === 0) return findings;

        // 1. Establish Baseline Latency
        let baselineTotal = 0;
        for (let i = 0; i < BASELINE_SAMPLES; i++) {
            const start = Date.now();
            await this.client.get(target.url);
            baselineTotal += (Date.now() - start);
        }
        const avgBaseline = baselineTotal / BASELINE_SAMPLES;

        // If site is naturally slow/unstable (>3s), skip time-based checks to avoid false positives
        if (avgBaseline > 3000) return findings;

        // 2. Test Time-Based Payloads
        for (const param of target.params) {
            const payloads = [
                { type: 'sqli', payload: `WAITFOR DELAY '0:0:${DELAY_SECONDS}'`, engine: 'MSSQL' },
                { type: 'sqli', payload: `SLEEP(${DELAY_SECONDS})`, engine: 'MySQL' },
                { type: 'sqli', payload: `pg_sleep(${DELAY_SECONDS})`, engine: 'PostgreSQL' },
                { type: 'cmd', payload: ` || sleep ${DELAY_SECONDS}`, engine: 'Command Injection' },
            ];

            for (const test of payloads) {
                const url = new URL(target.url);
                url.searchParams.set(param, test.payload);

                try {
                    const start = Date.now();
                    await this.client.get(url.toString());
                    const duration = Date.now() - start;

                    // Check if duration indicates a successful sleep
                    if (duration >= (avgBaseline + THRESHOLD_MS)) {
                        // Verify once more to reduce false positives
                        const verifyStart = Date.now();
                        await this.client.get(url.toString());
                        const verifyDuration = Date.now() - verifyStart;

                        if (verifyDuration >= (avgBaseline + THRESHOLD_MS)) {
                            findings.push({
                                id: `TIME-${test.type.toUpperCase()}-${Date.now()}`,
                                title: `Blind ${test.engine} (Time-Based)`,
                                owasp_category: 'A03:2021 - Injection',
                                severity: 'critical',
                                status: 'vulnerable',
                                detection_type: 'behavior',
                                confidence: 95,
                                evidence: [
                                    `Baseline Latency: ${avgBaseline.toFixed(0)}ms`,
                                    `Response Time with Payload: ${duration.toFixed(0)}ms`,
                                    `Payload: ${test.payload}`
                                ],
                                recommendation: 'Use parameterized queries and avoid system calls.',
                                references: ['https://owasp.org/Top10/A03_2021-Injection/'],
                                affected_url: target.url,
                                param,
                                payload: test.payload
                            });
                            break; // Found one valid injection for this param, move next
                        }
                    }
                } catch {
                    // Timeout or error might also indicate success depending on logic,
                    // but for stability we ignore errors in time-based checks.
                }
            }
        }

        return findings;
    }
}
