
import { HttpClient } from '../core/client.ts';
import { ScanConfig } from '../core/types.ts';

export class AuthHandler {
    private client: HttpClient;
    private config: ScanConfig;
    private sessionHeaders: Record<string, string> = {};

    constructor(client: HttpClient, config: ScanConfig) {
        this.client = client;
        this.config = config;
    }

    async login(loginUrl: string, credentials: { username?: string; password?: string }): Promise<boolean> {
        if (!credentials.username || !credentials.password) return false;

        console.log(`[Auth] Attempting login at ${loginUrl}`);

        try {
            // 1. Initial GET to fetch CSRF tokens and cookies
            const { response: getResponse } = await this.client.get(loginUrl);
            const getBody = await getResponse.text();

            // Extract cookies from GET response
            this.updateCookies(getResponse.headers);

            // 2. Extract CSRF Token (common patterns)
            const csrfToken = this.extractCsrfToken(getBody);

            // 3. Prepare Login Data
            const formData = new URLSearchParams();
            formData.append('username', credentials.username); // Try standard names first
            formData.append('email', credentials.username);    // Fallback/Alternate
            formData.append('password', credentials.password);
            if (csrfToken) {
                formData.append('_csrf', csrfToken);
                formData.append('csrf_token', csrfToken);
                formData.append('authenticity_token', csrfToken); // Rails
            }

            // 4. POST Login
            // We assume the form submits to the same URL for 'Lite' version.
            // In a full version, we would parse the <form action="...">
            const { response: postResponse } = await this.client.fetch(loginUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    ...this.sessionHeaders // Include cookies from GET
                },
                body: formData.toString(),
                redirect: 'manual'
            });

            // 5. Update Session State
            this.updateCookies(postResponse.headers);

            // Check success (redirect or 200 OK with new cookies)
            if (postResponse.status === 302 || postResponse.status === 303 || (postResponse.status === 200 && postResponse.headers.has('set-cookie'))) {
                console.log('[Auth] Login appears successful');
                return true;
            }

            console.log(`[Auth] Login failed: Status ${postResponse.status}`);
            return false;

        } catch (e) {
            console.error(`[Auth] Login error: ${e}`);
            return false;
        }
    }

    getSessionHeaders(): Record<string, string> {
        return this.sessionHeaders;
    }

    private updateCookies(headers: Headers) {
        const setCookie = headers.get('set-cookie');
        if (setCookie) {
            // Simple cookie merger (Replace existing)
            // For a robust implementation, we would parse discrete cookies, but this suffices for 'Lite'
            // combining multiple Set-Cookie headers is complex in Fetch API due to fold behavior,
            // but Deno/Browser usually gives comma-separated or we just take the last block.
            // Here we just append to a 'Cookie' header.

            const currentCookies = this.sessionHeaders['Cookie'] || '';
            // Naive append: assume basic key=value; 
            // Real-world needs a CookieJar library, but we are keeping it dependency-free for Supabase Edge Functions
            this.sessionHeaders['Cookie'] = currentCookies ? `${currentCookies}; ${setCookie}` : setCookie;
        }
    }

    private extractCsrfToken(html: string): string | null {
        const patterns = [
            /name=["']_csrf["']\s+value=["']([^"']+)["']/i,
            /name=["']csrf_token["']\s+value=["']([^"']+)["']/i,
            /name=["']authenticity_token["']\s+value=["']([^"']+)["']/i, // Rails
            /content=["']([^"']+)["']\s+name=["']csrf-token["']/i // Meta tag
        ];

        for (const pattern of patterns) {
            const match = html.match(pattern);
            if (match) return match[1];
        }
        return null;
    }
}
